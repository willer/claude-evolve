#!/bin/bash

set -e

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../lib/config.sh
source "$SCRIPT_DIR/../lib/config.sh"
# shellcheck source=../lib/csv-lock.sh
source "$SCRIPT_DIR/../lib/csv-lock.sh"
# shellcheck source=../lib/ai-cli.sh
source "$SCRIPT_DIR/../lib/ai-cli.sh"

# Use CLAUDE_EVOLVE_CONFIG if set, otherwise default
if [[ -n ${CLAUDE_EVOLVE_CONFIG:-} ]]; then
  load_config "$CLAUDE_EVOLVE_CONFIG"
else
  load_config
fi

# Helper function to call AI with limit check
call_ai_with_limit_check() {
  local prompt="$1"
  local generation="${2:-01}"  # Default to generation 01 if not provided
  
  # Calculate hash value for round-robin based on generation
  local gen_num
  if [[ $generation =~ ^0*([0-9]+)$ ]]; then
    gen_num=$((10#${BASH_REMATCH[1]}))
  else
    gen_num=1
  fi
  
  # Use centralized AI library for ideation
  local ai_output
  ai_output=$(call_ai_with_round_robin "$prompt" "ideate" "$gen_num")
  local ai_exit_code=$?
  
  # Handle special exit codes
  if [[ $ai_exit_code -eq 3 ]]; then
    # All models hit usage limits
    echo -e "\033[31m[ERROR] ALL AI MODELS HIT USAGE LIMITS!\033[0m" >&2
    echo -e "\033[31m[ERROR] Ideation halted due to API rate limits.\033[0m" >&2
    echo -e "\033[33m[INFO] Please wait for the rate limits to reset before continuing.\033[0m" >&2
    echo -e "\033[33m[INFO] No ideas were generated. Run ideate again when the limits reset.\033[0m" >&2
    exit 1
  fi
  
  if [[ $ai_exit_code -eq 0 ]]; then
    # For ideation, AI modifies files directly - just return success
    echo "[INFO] AI succeeded" >&2
    return 0
  else
    return $ai_exit_code
  fi
}


# Backward compatibility alias
call_claude_with_limit_check() {
  call_ai_with_limit_check "$@"
}

# Robust AI calling with fallbacks across all available models
call_ai_for_ideation() {
  local prompt="$1"
  local generation="${2:-01}"
  local expected_count="${3:-1}"  # Number of ideas expected to be added
  local temp_csv_file="${4:-temp-csv-$$.csv}"  # Optional temp CSV filename
  
  # Calculate hash value for round-robin based on generation
  local gen_num
  if [[ $generation =~ ^0*([0-9]+)$ ]]; then
    gen_num=$((10#${BASH_REMATCH[1]}))
  else
    gen_num=1
  fi
  
  # Get the current row count before any modifications
  local original_csv_count
  if [[ -f "$temp_csv_file" ]]; then
    original_csv_count=$(grep -v '^[[:space:]]*$' "$temp_csv_file" | tail -n +2 | wc -l)
  else
    original_csv_count=0
  fi
  
  # Use centralized AI library
  local ai_output
  ai_output=$(call_ai_with_round_robin "$prompt" "ideate" "$gen_num")
  local ai_exit_code=$?
  
  # Handle special exit codes
  # No special handling for exit codes anymore
  
  if [[ $ai_exit_code -eq 0 ]]; then
    # For ideation, we need to verify the CSV file was actually modified
    if [[ -f "$temp_csv_file" ]]; then
      local new_csv_count
      new_csv_count=$(grep -v '^[[:space:]]*$' "$temp_csv_file" | tail -n +2 | wc -l)
      
      if [[ $new_csv_count -gt $original_csv_count ]]; then
        echo "[INFO] AI completed successfully and modified CSV ($new_csv_count vs $original_csv_count rows)" >&2
        return 0
      else
        echo "[INFO] $model returned exit code 0 but didn't modify CSV file" >&2
        echo "[DEBUG] Expected file: $temp_csv_file" >&2
        echo "[DEBUG] Original count: $original_csv_count, New count: $new_csv_count" >&2
        return 1
      fi
    else
      echo "[INFO] Exit code 0 but temp CSV file not found: $temp_csv_file" >&2
      echo "[DEBUG] Current directory: $(pwd)" >&2
      echo "[DEBUG] Files matching temp-csv-*.csv:" >&2
      ls -la temp-csv-*.csv 2>&1 >&2
      return 1
    fi
  fi
  
  echo "[INFO] No AI model successfully modified the CSV file" >&2
  return 1
}

# Parse arguments
use_strategies=true

while [[ $# -gt 0 ]]; do
  case $1 in
  --help)
    cat <<EOF
claude-evolve ideate - Generate new algorithm ideas using evolutionary strategies

USAGE:
  claude-evolve ideate [--legacy N]

OPTIONS:
  --legacy N  Use legacy mode with N ideas (ignores strategy config)
  --help      Show this help message

DESCRIPTION:
  Generates algorithm ideas using multi-strategy evolutionary approach:
  - Novel exploration: Pure creativity, global search
  - Hill climbing: Parameter tuning of top performers  
  - Structural mutation: Algorithmic changes to top performers
  - Crossover hybrid: Combine successful approaches
  
  Strategy distribution is configured in evolution/config.yaml
EOF
    exit 0
    ;;
  --legacy)
    use_strategies=false
    shift
    if [[ $1 =~ ^[0-9]+$ ]]; then
      TOTAL_IDEAS=$1
      shift
    else
      echo "[ERROR] --legacy requires a number" >&2
      exit 1
    fi
    ;;
  *)
    echo "[ERROR] Unknown option: $1" >&2
    exit 1
    ;;
  esac
done

# Check workspace using config
if [[ ! -d "$FULL_EVOLUTION_DIR" ]]; then
  echo "[ERROR] Evolution workspace not found: $FULL_EVOLUTION_DIR. Run 'claude-evolve setup' first." >&2
  exit 1
fi

# Ensure CSV exists
if [[ ! -f "$FULL_CSV_PATH" ]]; then
  echo "id,basedOnId,description,performance,status" >"$FULL_CSV_PATH"
fi

# Validate strategy configuration
if [[ $use_strategies == true ]]; then
  total_check=$((NOVEL_EXPLORATION + HILL_CLIMBING + STRUCTURAL_MUTATION + CROSSOVER_HYBRID))
  if [[ $total_check -ne $TOTAL_IDEAS ]]; then
    echo "[ERROR] Strategy counts don't sum to total_ideas ($total_check != $TOTAL_IDEAS)" >&2
    echo "Check your evolution/config.yaml configuration" >&2
    exit 1
  fi
fi

# Get next generation number that doesn't have existing Python files
get_next_generation() {
  # Start with generation 1 if no CSV exists
  local start_gen=1
  
  if [[ -f "$FULL_CSV_PATH" ]]; then
    # Use Python for proper CSV parsing to find max generation
    local max_gen
    max_gen=$("$PYTHON_CMD" -c "
import csv
max_gen = 0
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            id_field = row[0].strip()
            if id_field.startswith('gen') and '-' in id_field:
                try:
                    gen_part = id_field.split('-')[0]  # e.g., 'gen01'
                    gen_num = int(gen_part[3:])  # Extract number after 'gen'
                    max_gen = max(max_gen, gen_num)
                except (ValueError, IndexError):
                    pass
print(max_gen)
")
    # Start checking from the next generation after max
    start_gen=$((max_gen + 1))
  fi
  
  # Keep incrementing until we find a generation with no Python files
  local candidate_gen=$start_gen
  while true; do
    local gen_formatted=$(printf "%02d" $candidate_gen)
    
    # Check if any Python files exist for this generation
    local py_files_exist=false
    if ls "$FULL_OUTPUT_DIR"/evolution_gen${gen_formatted}-*.py >/dev/null 2>&1; then
      py_files_exist=true
    fi
    
    if [[ "$py_files_exist" == "false" ]]; then
      # This generation is safe to use
      echo "$gen_formatted"
      return
    else
      echo "[WARN] Generation $gen_formatted already has Python files, skipping to next generation" >&2
      candidate_gen=$((candidate_gen + 1))
      
      # Safety check to prevent infinite loop
      if [[ $candidate_gen -gt 999 ]]; then
        echo "[ERROR] Could not find a safe generation number (checked up to 999)" >&2
        exit 1
      fi
    fi
  done
}

# This function is no longer used with direct CSV modification approach
# Keeping for backward compatibility but it's not called anywhere
get_next_id_number() {
  "$PYTHON_CMD" -c "
import csv
import re
max_id = 0
pattern = re.compile(r'^gen$CURRENT_GENERATION-(\d+)$')
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            match = pattern.match(row[0].strip())
            if match:
                max_id = max(max_id, int(match.group(1)))
print(max_id + 1)
"
}

# Validate that AI directly modified the CSV file
validate_direct_csv_modification() {
  local temp_csv="$1"
  local expected_count="$2"
  local idea_type="$3"
  
  # Check if the file was actually modified
  if [[ ! -f "$temp_csv" ]]; then
    echo "[ERROR] CSV file was not found after AI modification" >&2
    return 1
  fi
  
  # Get the count before modification from the temp CSV (which was copied from original before AI ran)
  # We need to track this before the AI runs by reading from the beginning state
  # First, get a fresh count from the current main CSV (which reflects any previous operations in this session)
  local current_original_count
  current_original_count=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  
  # Count data rows in the modified temp CSV
  local new_count
  new_count=$(grep -v '^[[:space:]]*$' "$temp_csv" | tail -n +2 | wc -l)
  
  echo "[DEBUG] Current main CSV data rows: $current_original_count" >&2
  echo "[DEBUG] Modified temp CSV data rows: $new_count" >&2
  echo "[DEBUG] Expected to add: $expected_count ideas" >&2
  
  # Check if AI overwrote the file instead of appending
  if [[ $new_count -lt $current_original_count ]]; then
    echo "[ERROR] AI overwrote the CSV file instead of appending ($new_count < $current_original_count)" >&2
    echo "[DEBUG] First 10 lines of CSV after AI attempt:" >&2
    head -10 "$temp_csv" >&2
    return 1
  fi
  
  # Check if no changes were made
  if [[ $new_count -eq $current_original_count ]]; then
    echo "[ERROR] CSV file wasn't modified - same number of data rows ($new_count = $current_original_count)" >&2
    echo "[DEBUG] First 10 lines of CSV after AI attempt:" >&2
    head -10 "$temp_csv" >&2
    return 1
  fi
  
  local added_count=$((new_count - current_original_count))
  if [[ $added_count -ne $expected_count ]]; then
    echo "[WARN] Expected to add $expected_count ideas but added $added_count" >&2
  fi
  
  # Use proper locking to safely update the CSV
  echo "[INFO] Acquiring CSV lock to apply changes..."
  
  # Set the lockfile path
  CSV_LOCKFILE="$FULL_EVOLUTION_DIR/.evolution.csv.lock"
  
  if ! acquire_csv_lock; then
    echo "[ERROR] Failed to acquire CSV lock for update" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Get just the new entries (skip header and existing entries)
  local original_line_count=$(wc -l < "$FULL_CSV_PATH")
  
  # Append only the new lines from temp CSV to the main CSV
  tail -n +$((original_line_count + 1)) "$temp_csv" >> "$FULL_CSV_PATH"
  
  # Clean up temp file
  rm -f "$temp_csv"
  
  # Release the lock
  release_csv_lock
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  return 0
}

# DEPRECATED: Old validation function for CSV output approach
validate_and_apply_csv_modification_old() {
  local modified_csv="$1"
  local temp_csv="$2"
  local expected_count="$3"
  local idea_type="$4"
  
  # Check if the response looks like an error message (but not if it's just CSV data containing these words)
  if echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    # This looks like a CSV file, not an error message
    echo "[DEBUG] AI returned what appears to be a CSV file" >&2
  elif echo "$modified_csv" | grep -qi "error\|failed\|limit\|exceeded\|sorry\|cannot\|unable"; then
    echo "[ERROR] AI failed to modify CSV and returned an error message:" >&2
    echo "$modified_csv" | head -200 >&2
    return 1
  fi
  
  # Check if response is too short to be a valid CSV
  if [[ ${#modified_csv} -lt 50 ]]; then
    echo "[ERROR] AI response is too short to be a valid CSV (${#modified_csv} chars):" >&2
    echo "$modified_csv" >&2
    return 1
  fi
  
  # Extract CSV from AI output (in case there's extra text before it)
  local csv_start_line
  csv_start_line=$(echo "$modified_csv" | grep -n "id,basedOnId,description,performance,status" | head -1 | cut -d: -f1)
  
  if [[ -n "$csv_start_line" ]]; then
    # Extract CSV starting from the header line
    modified_csv=$(echo "$modified_csv" | tail -n +$csv_start_line)
    echo "[DEBUG] Found CSV header at line $csv_start_line, extracting from there" >&2
  elif ! echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    echo "[ERROR] AI failed to return a valid CSV file. Expected CSV with header, but got:" >&2
    echo "$modified_csv" | head -c 500 >&2
    echo "" >&2
    echo "[DEBUG] The AI was asked to output the complete modified CSV but didn't" >&2
    return 1
  fi
  
  # Write the modified CSV to temp file
  echo "$modified_csv" > "$temp_csv"
  
  # Validate the modified CSV has more entries than original
  local original_count
  original_count=$(wc -l < "$FULL_CSV_PATH")
  local new_count
  new_count=$(wc -l < "$temp_csv")
  
  echo "[DEBUG] Original CSV line count: $original_count" >&2
  echo "[DEBUG] Modified CSV line count: $new_count" >&2
  echo "[DEBUG] Expected to add: $expected_count ideas" >&2
  
  if [[ $new_count -le $original_count ]]; then
    echo "[ERROR] Modified CSV doesn't have more entries ($new_count <= $original_count)" >&2
    echo "[DEBUG] First 10 lines of modified CSV:" >&2
    head -10 "$temp_csv" >&2
    return 1
  fi
  
  local added_count=$((new_count - original_count))
  if [[ $added_count -ne $expected_count ]]; then
    echo "[WARN] Expected to add $expected_count ideas but added $added_count" >&2
  fi
  
  # Use proper locking to safely update the CSV
  echo "[INFO] Acquiring CSV lock to apply changes..."
  
  # Set the lockfile path
  CSV_LOCKFILE="$FULL_EVOLUTION_DIR/.evolution.csv.lock"
  
  if ! acquire_csv_lock; then
    echo "[ERROR] Failed to acquire CSV lock for update" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Get just the new entries (skip header and existing entries)
  local original_line_count=$(wc -l < "$FULL_CSV_PATH")
  
  # Append only the new lines from temp CSV to the main CSV
  tail -n +$((original_line_count + 1)) "$temp_csv" >> "$FULL_CSV_PATH"
  
  # Clean up temp file
  rm -f "$temp_csv"
  
  # Release the lock
  release_csv_lock
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  return 0
}

# DEPRECATED: Old two-step process function - kept for reference
process_ai_ideas_direct_old() {
  local count="$1"
  local idea_type="$2"  # novel, hill-climbing, structural, crossover
  local top_performers="${3:-}"  # Optional, for non-novel ideas
  local ai_output="$4"  # The AI's response with ideas
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[DEBUG] Starting CSV modification for $count $idea_type ideas" >&2
  echo "[DEBUG] Original CSV path: $FULL_CSV_PATH" >&2
  echo "[DEBUG] Temp CSV path: $temp_csv" >&2
  echo "[DEBUG] Original CSV size: $(wc -l < "$FULL_CSV_PATH") lines" >&2
  
  # Build prompt for AI to directly modify the CSV
  local csv_prompt="I need you to add exactly $count new $idea_type ideas to this CSV file.

Here are the $count $idea_type ideas to add:
$ai_output

Current CSV contents:
$(cat "$temp_csv")

Instructions:
1. Add exactly $count new rows to the CSV
2. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
3. For each idea, create a row with: id,parent_id,description,,pending
4. For novel ideas: leave parent_id empty
5. For other idea types: use appropriate parent IDs from these top performers:
$top_performers

IMPORTANT: Output the complete modified CSV file. Do not add any explanation or other text - just output the CSV."
  
  echo "[INFO] Having AI directly modify CSV with $count $idea_type ideas..."
  
  # Get AI to modify the CSV with fallbacks
  local modified_csv
  local stderr_file="$FULL_EVOLUTION_DIR/stderr-$$.txt"
  if ! modified_csv=$(call_ai_for_ideation "$csv_prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to modify CSV" >&2
    cat "$stderr_file" >&2
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Check if the response looks like an error message
  if echo "$modified_csv" | grep -qi "error\|failed\|limit\|exceeded\|sorry\|cannot\|unable"; then
    echo "[ERROR] AI failed to modify CSV and returned an error message:" >&2
    echo "$modified_csv" | head -200 >&2
    rm -f "$temp_csv" 
    return 1
  fi
  
  # Check if response is too short to be a valid CSV
  if [[ ${#modified_csv} -lt 50 ]]; then
    echo "[ERROR] AI response is too short to be a valid CSV (${#modified_csv} chars):" >&2
    echo "$modified_csv" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Extract CSV from AI output (in case there's extra text before it)
  local csv_start_line
  csv_start_line=$(echo "$modified_csv" | grep -n "id,basedOnId,description,performance,status" | head -1 | cut -d: -f1)
  
  if [[ -n "$csv_start_line" ]]; then
    # Extract CSV starting from the header line
    modified_csv=$(echo "$modified_csv" | tail -n +$csv_start_line)
    echo "[DEBUG] Found CSV header at line $csv_start_line, extracting from there" >&2
  elif ! echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    echo "[ERROR] AI failed to return a valid CSV file. Expected CSV with header, but got:" >&2
    echo "$modified_csv" | head -c 500 >&2
    echo "" >&2
    echo "[DEBUG] The AI was asked to output the complete modified CSV but didn't" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Write the modified CSV to temp file
  echo "$modified_csv" > "$temp_csv"
  
  # Debug: Show the AI's CSV modification attempt
  echo "[DEBUG] AI response length: ${#modified_csv} characters" >&2
  echo "[DEBUG] First 300 chars of AI response:" >&2
  echo "$modified_csv" | head -c 300 >&2
  echo "" >&2
  echo "[DEBUG] Last 300 chars of AI response:" >&2
  echo "$modified_csv" | tail -c 300 >&2
  echo "" >&2
  
  # Validate the modified CSV has more entries than original
  local original_count
  original_count=$(wc -l < "$FULL_CSV_PATH")
  local new_count
  new_count=$(wc -l < "$temp_csv")
  
  echo "[DEBUG] Original CSV line count: $original_count" >&2
  echo "[DEBUG] Modified CSV line count: $new_count" >&2
  echo "[DEBUG] Expected to add: $count ideas" >&2
  
  if [[ $new_count -le $original_count ]]; then
    echo "[ERROR] Modified CSV doesn't have more entries ($new_count <= $original_count)" >&2
    echo "[DEBUG] Temp CSV contents:" >&2
    cat "$temp_csv" | head -10 >&2
    echo "[DEBUG] Original CSV contents:" >&2
    cat "$FULL_CSV_PATH" | head -10 >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  local added_count=$((new_count - original_count))
  if [[ $added_count -ne $count ]]; then
    echo "[WARN] Expected to add $count ideas but added $added_count" >&2
  fi
  
  # Use proper locking to safely update the CSV
  echo "[INFO] Acquiring CSV lock to apply changes..."
  
  # Set the lockfile path
  CSV_LOCKFILE="$FULL_EVOLUTION_DIR/.evolution.csv.lock"
  
  if ! acquire_csv_lock; then
    echo "[ERROR] Failed to acquire CSV lock for update" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Get just the new entries (skip header and existing entries)
  local original_line_count=$(wc -l < "$FULL_CSV_PATH")
  
  # Append only the new lines from temp CSV to the main CSV
  tail -n +$((original_line_count + 1)) "$temp_csv" >> "$FULL_CSV_PATH"
  
  # Clean up temp file
  rm -f "$temp_csv"
  
  # Release the lock
  release_csv_lock
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  
  return 0
}

# Get list of existing Python files for a generation
get_existing_py_files_for_generation() {
  local generation="$1"
  local py_files=""
  
  # List all Python files for this generation
  for py_file in "$FULL_OUTPUT_DIR"/evolution_gen${generation}-*.py; do
    if [[ -f "$py_file" ]]; then
      local basename=$(basename "$py_file" .py)
      local id="${basename#evolution_}"
      if [[ -n "$py_files" ]]; then
        py_files="$py_files, $id"
      else
        py_files="$id"
      fi
    fi
  done
  
  echo "$py_files"
}

# Add existing Python files warning to prompt
add_existing_files_warning() {
  local prompt="$1"
  local generation="$2"
  local existing_py_files=$(get_existing_py_files_for_generation "$generation")
  
  if [[ -n "$existing_py_files" ]]; then
    prompt+="

WARNING: The following IDs already have Python files and MUST NOT be reused: $existing_py_files
Skip these IDs when assigning new IDs (e.g., if gen$generation-001 and gen$generation-002 exist as Python files, start with gen$generation-003)"
  fi
  
  echo "$prompt"
}

# Get next available ID for current generation
get_next_id() {
  local generation="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo "gen${generation}-001"
    return
  fi
  
  # Use Python for proper CSV parsing
  local max_id
  max_id=$("$PYTHON_CMD" -c "
import csv
import re
max_id = 0
pattern = re.compile(r'^gen${generation}-(\d+)$')
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            id_field = row[0].strip()
            match = pattern.match(id_field)
            if match:
                id_num = int(match.group(1))
                max_id = max(max_id, id_num)
print(max_id)
")
  
  # Format next ID with generation and 3-digit number
  printf "gen%s-%03d" "$generation" $((max_id + 1))
}


# Get top performers for parent selection (absolute + top novel candidates)
get_top_performers() {
  local num_requested="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo ""
    return
  fi
  
  # Use Python to properly parse CSV and find top performers + top novel candidates
  "$PYTHON_CMD" -c "
import csv
import sys

with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader)  # Skip header
    
    completed = []
    novel = []
    
    # Collect all completed candidates
    for row in reader:
        if len(row) >= 5 and row[3] and row[4] == 'complete':
            try:
                candidate_id = row[0]
                parent_id = row[1] if len(row) > 1 else ''
                description = row[2] if len(row) > 2 else ''
                score = float(row[3])
                
                completed.append((candidate_id, description, score))
                
                # Track novel candidates separately
                if not parent_id:
                    novel.append((candidate_id, description, score))
                    
            except ValueError:
                pass
    
    # Sort absolute leaders by score (descending)
    completed.sort(key=lambda x: x[2], reverse=True)
    
    # Sort novel candidates by score (descending)
    novel.sort(key=lambda x: x[2], reverse=True)
    
    # Collect top performers
    selected_ids = set()
    results = []
    
    # Add top absolute performers
    for i, (candidate_id, description, score) in enumerate(completed[:$num_requested]):
        results.append(f'{candidate_id},{description},{score}')
        selected_ids.add(candidate_id)
    
    # Add top novel candidates (if not already selected)
    novel_count = 0
    for candidate_id, description, score in novel:
        if candidate_id not in selected_ids and novel_count < $NUM_REVOLUTION:
            results.append(f'{candidate_id},{description},{score}')
            selected_ids.add(candidate_id)
            novel_count += 1
    
    # Output all selected candidates
    for result in results:
        print(result)
"
}



# Generate ideas using AI with multi-strategy approach
ideate_ai_strategies() {
  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[ERROR] $BRIEF_FILE not found. Run 'claude-evolve setup' first." >&2
    exit 1
  fi

  # Baseline should already be evaluated by run command

  # Get top performers (now includes top novel candidates)
  local top_performers
  top_performers=$(get_top_performers "$NUM_ELITES")
  
  if [[ -z $top_performers ]]; then
    echo "[INFO] No completed algorithms found, will use baseline algorithm for hill climbing"
    # For hill climbing and mutations, use the baseline algorithm
    # Use a special ID that validation script will recognize
    top_performers="000,Baseline Algorithm (algorithm.py),0.0"
  fi

  echo "[INFO] Generating $TOTAL_IDEAS ideas using multi-strategy approach:"
  echo "  Novel exploration: $NOVEL_EXPLORATION"
  echo "  Hill climbing: $HILL_CLIMBING" 
  echo "  Structural mutation: $STRUCTURAL_MUTATION"
  echo "  Crossover hybrid: $CROSSOVER_HYBRID"

  # Generate each type of idea by having Claude directly edit the CSV
  # Track successes - continue even if some strategies fail
  local strategies_attempted=0
  local strategies_succeeded=0
  
  if [[ $NOVEL_EXPLORATION -gt 0 ]]; then
    ((strategies_attempted++))
    if generate_novel_ideas_direct "$NOVEL_EXPLORATION"; then
      ((strategies_succeeded++))
    else
      echo "[WARN] Novel exploration strategy failed, continuing with other strategies" >&2
    fi
  fi
  
  if [[ $HILL_CLIMBING -gt 0 ]]; then
    ((strategies_attempted++))
    if generate_hill_climbing_direct "$HILL_CLIMBING" "$top_performers"; then
      ((strategies_succeeded++))
    else
      echo "[WARN] Hill climbing strategy failed, continuing with other strategies" >&2
    fi
  fi
  
  if [[ $STRUCTURAL_MUTATION -gt 0 ]]; then
    ((strategies_attempted++))
    if generate_structural_mutation_direct "$STRUCTURAL_MUTATION" "$top_performers"; then
      ((strategies_succeeded++))
    else
      echo "[WARN] Structural mutation strategy failed, continuing with other strategies" >&2
    fi
  fi
  
  if [[ $CROSSOVER_HYBRID -gt 0 ]]; then
    ((strategies_attempted++))
    if generate_crossover_direct "$CROSSOVER_HYBRID" "$top_performers"; then
      ((strategies_succeeded++))
    else
      echo "[WARN] Crossover strategy failed, continuing with other strategies" >&2
    fi
  fi
  
  echo "[INFO] Strategy results: $strategies_succeeded/$strategies_attempted succeeded" >&2
  
  # Success if at least one strategy worked
  if [[ $strategies_succeeded -gt 0 ]]; then
    return 0
  else
    echo "[ERROR] All ideation strategies failed" >&2
    return 1
  fi
}

# Generate novel exploration ideas using direct CSV modification
generate_novel_ideas_direct() {
  local count="$1"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count novel exploration ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  # Get existing Python files for this generation to avoid ID collisions
  local existing_py_files=$(get_existing_py_files_for_generation "$CURRENT_GENERATION")
  
  local prompt="I need you to use your file editing capabilities to APPEND exactly $count novel algorithmic ideas to the CSV file: $temp_csv_basename

Current evolution context:
- Generation: $CURRENT_GENERATION
- Algorithm: algorithm.py (base algorithm)
- Brief: $(head -5 "$FULL_BRIEF_PATH" 2>/dev/null | head -c 500 || echo "No brief file found")

CRITICAL INSTRUCTIONS:
1. Use the Read tool to examine the current CSV file
2. DO NOT DELETE OR REPLACE ANY EXISTING ROWS - YOU MUST PRESERVE ALL EXISTING DATA
3. Find the highest ID number for generation $CURRENT_GENERATION (e.g., if gen$CURRENT_GENERATION-003 exists, next should be gen$CURRENT_GENERATION-004)
4. If no gen$CURRENT_GENERATION entries exist yet, start with gen$CURRENT_GENERATION-001"
  
  if [[ -n "$existing_py_files" ]]; then
    prompt+="
5. IMPORTANT: The following IDs already have Python files and MUST NOT be reused: $existing_py_files
6. Skip these IDs when assigning new IDs (e.g., if gen$CURRENT_GENERATION-001 and gen$CURRENT_GENERATION-002 exist as Python files, start with gen$CURRENT_GENERATION-003)"
  else
    prompt+="
5. No existing Python files found for generation $CURRENT_GENERATION"
  fi
  
  prompt+="
6. Use the Edit or MultiEdit tool to APPEND exactly $count new rows AT THE END of the CSV file
7. For each idea, create a row with: id,,description,,pending (empty parent_id for novel ideas)
8. Each description should be one clear sentence describing a novel algorithmic approach
9. Focus on creative, ambitious ideas that haven't been tried yet
10. Consider machine learning, new indicators, regime detection, risk management, etc.

IMPORTANT: You must APPEND new rows to the existing CSV file. DO NOT replace the file contents. All existing rows must remain unchanged.
CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly.
CRITICAL: Do NOT use any git commands (git add, git commit, git reset, etc.). Only modify the file directly."

  # Debug prompt size and context
  echo "[DEBUG] Novel ideas prompt length: ${#prompt} characters" >&2
  echo "[DEBUG] Working dir: $(pwd)" >&2
  echo "[DEBUG] Evolution dir: $FULL_EVOLUTION_DIR" >&2
  echo "[DEBUG] Temp CSV: $temp_csv" >&2
  if [[ -f "$temp_csv" ]]; then
    echo "[DEBUG] Temp CSV exists, size: $(wc -l < "$temp_csv") lines" >&2
  else
    echo "[DEBUG] Temp CSV does not exist yet" >&2
  fi

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Debug: Show files in evolution directory
  echo "[DEBUG] Current directory: $(pwd)" >&2
  echo "[DEBUG] Temp CSV exists: $(ls -la "$temp_csv_basename" 2>&1)" >&2
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  # Temporarily show stderr for debugging
  if ! ai_response=$(call_ai_for_ideation "$prompt" "$CURRENT_GENERATION" "$count" "$temp_csv_basename"); then
    echo "[ERROR] All AI models failed to generate novel ideas" >&2
    echo "[DEBUG] Stderr output from AI calls:" >&2
    cat "$stderr_file" >&2
    echo "[DEBUG] Temp CSV location: $temp_csv" >&2
    echo "[DEBUG] Working directory: $(pwd)" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "novel"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Novel exploration ideas generated successfully"
  return 0
}

# Generate hill climbing ideas using direct CSV modification
generate_hill_climbing_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count hill climbing ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Get existing Python files for this generation to avoid ID collisions
  local existing_py_files=$(get_existing_py_files_for_generation "$CURRENT_GENERATION")
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to APPEND exactly $count parameter tuning ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use one of these exact parent IDs: $valid_parent_ids

Successful algorithms to tune:
$top_performers

CRITICAL INSTRUCTION: Before generating parameter tuning ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

CRITICAL INSTRUCTIONS:
1. Use the Read tool to examine the current CSV file
2. DO NOT DELETE OR REPLACE ANY EXISTING ROWS - YOU MUST PRESERVE ALL EXISTING DATA
3. Find the highest ID number for generation $CURRENT_GENERATION (e.g., if gen$CURRENT_GENERATION-003 exists, next should be gen$CURRENT_GENERATION-004)
4. If no gen$CURRENT_GENERATION entries exist yet, start with gen$CURRENT_GENERATION-001
5. Use the Edit or MultiEdit tool to APPEND exactly $count new rows AT THE END of the CSV file
6. For each idea, create a row with: id,parent_id,description,,pending
7. Each parent_id MUST be one of: $valid_parent_ids
8. Each description should focus on adjusting specific parameters that exist in the parent's source code
9. Include current and new parameter values (e.g., \"Lower rsi_entry from 21 to 18\")

IMPORTANT: You must APPEND new rows to the existing CSV file. DO NOT replace the file contents. All existing rows must remain unchanged.
CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly.
CRITICAL: Do NOT use any git commands (git add, git commit, git reset, etc.). Only modify the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  # Temporarily show stderr for debugging
  if ! ai_response=$(call_ai_for_ideation "$prompt" "$CURRENT_GENERATION" "$count" "$temp_csv_basename"); then
    echo "[ERROR] All AI models failed to generate hill climbing ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "hill-climbing"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Hill climbing ideas generated successfully"
  return 0
}

# Generate structural mutation ideas using direct CSV modification
generate_structural_mutation_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count structural mutation ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Get existing Python files for this generation to avoid ID collisions
  local existing_py_files=$(get_existing_py_files_for_generation "$CURRENT_GENERATION")
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to APPEND exactly $count structural modification ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use one of these exact parent IDs: $valid_parent_ids

Successful algorithms to modify structurally:
$top_performers

CRITICAL INSTRUCTION: Before generating structural modification ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

CRITICAL INSTRUCTIONS:
1. Use the Read tool to examine the current CSV file
2. DO NOT DELETE OR REPLACE ANY EXISTING ROWS - YOU MUST PRESERVE ALL EXISTING DATA
3. Find the highest ID number for generation $CURRENT_GENERATION (e.g., if gen$CURRENT_GENERATION-003 exists, next should be gen$CURRENT_GENERATION-004)
4. If no gen$CURRENT_GENERATION entries exist yet, start with gen$CURRENT_GENERATION-001
5. Use the Edit or MultiEdit tool to APPEND exactly $count new rows AT THE END of the CSV file
6. For each idea, create a row with: id,parent_id,description,,pending
7. Each parent_id MUST be one of: $valid_parent_ids
8. Each description should focus on architectural/structural changes based on the parent's actual code
9. Reference actual components/methods found in the source code

IMPORTANT: You must APPEND new rows to the existing CSV file. DO NOT replace the file contents. All existing rows must remain unchanged.
CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly.
CRITICAL: Do NOT use any git commands (git add, git commit, git reset, etc.). Only modify the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  # Temporarily show stderr for debugging
  if ! ai_response=$(call_ai_for_ideation "$prompt" "$CURRENT_GENERATION" "$count" "$temp_csv_basename"); then
    echo "[ERROR] All AI models failed to generate structural mutation ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "structural"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Structural mutation ideas generated successfully"
  return 0
}

# Generate crossover hybrid ideas using direct CSV modification
generate_crossover_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count crossover hybrid ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Get existing Python files for this generation to avoid ID collisions
  local existing_py_files=$(get_existing_py_files_for_generation "$CURRENT_GENERATION")
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to APPEND exactly $count hybrid combination ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use ONLY these exact parent IDs: $valid_parent_ids

Top performers to combine (reference at least 2 in each idea):
$top_performers

CRITICAL INSTRUCTION: Before generating hybrid combination ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

CRITICAL INSTRUCTIONS:
1. Use the Read tool to examine the current CSV file
2. DO NOT DELETE OR REPLACE ANY EXISTING ROWS - YOU MUST PRESERVE ALL EXISTING DATA
3. Find the highest ID number for generation $CURRENT_GENERATION (e.g., if gen$CURRENT_GENERATION-003 exists, next should be gen$CURRENT_GENERATION-004)
4. If no gen$CURRENT_GENERATION entries exist yet, start with gen$CURRENT_GENERATION-001
5. Use the Edit or MultiEdit tool to APPEND exactly $count new rows AT THE END of the CSV file
6. For each idea, create a row with: id,parent_id,description,,pending
7. Each parent_id MUST be one of: $valid_parent_ids (choose the primary parent)
8. Each description should combine actual elements from 2+ algorithms based on their source code
9. Reference specific components/features found in the actual source code

IMPORTANT: You must APPEND new rows to the existing CSV file. DO NOT replace the file contents. All existing rows must remain unchanged.
CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly.
CRITICAL: Do NOT use any git commands (git add, git commit, git reset, etc.). Only modify the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  # Temporarily show stderr for debugging
  if ! ai_response=$(call_ai_for_ideation "$prompt" "$CURRENT_GENERATION" "$count" "$temp_csv_basename"); then
    echo "[ERROR] All AI models failed to generate crossover hybrid ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "crossover"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Crossover hybrid ideas generated successfully"
  return 0
}

# Legacy AI generation mode (for backward compatibility)
ideate_ai_legacy() {
  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[ERROR] $BRIEF_FILE not found. Run 'claude-evolve setup' first." >&2
    exit 1
  fi

  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $TOTAL_IDEAS ideas (legacy mode)..."
  echo "[DEBUG] Original CSV has $(wc -l < "$FULL_CSV_PATH") lines" >&2

  # Get top performers for context
  local top_performers=""
  if [[ -f "$FULL_CSV_PATH" ]]; then
    # Simple top performers extraction (lines with non-empty performance)
    top_performers=$(awk -F, 'NR > 1 && $4 != "" { print $1 ": " $3 " (score: " $4 ")" }' "$FULL_CSV_PATH" | head -5)
  fi

  # Build prompt for direct CSV modification
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $TOTAL_IDEAS algorithmic ideas to the CSV file: $temp_csv_basename

Algorithm files for context:
- Base algorithm: algorithm.py  
- Evolved algorithms: evolution_*.py

IMPORTANT: Before generating ideas, you should:
1. Use the Read tool to examine the base algorithm to understand the codebase structure and possibilities
2. Use the Read tool to examine ALL existing evolution_*.py files to see what modifications have been attempted
3. Consider which approaches might work well

Project Brief:
$(cat "$FULL_BRIEF_PATH")"

  if [[ -n $top_performers ]]; then
    prompt+="

Top Performing Algorithms So Far:
$top_performers"
  fi

  prompt+="

CRITICAL INSTRUCTIONS:
1. Use the Read tool to examine the current CSV file
2. DO NOT DELETE OR REPLACE ANY EXISTING ROWS - YOU MUST PRESERVE ALL EXISTING DATA
3. Find the highest ID number for generation $CURRENT_GENERATION (e.g., if gen$CURRENT_GENERATION-003 exists, next should be gen$CURRENT_GENERATION-004)
4. If no gen$CURRENT_GENERATION entries exist yet, start with gen$CURRENT_GENERATION-001
5. Use the Edit or MultiEdit tool to APPEND exactly $TOTAL_IDEAS new rows AT THE END of the CSV file
6. For each idea, create a row with: id,parent_id,description,,pending
7. Mix both parameter tuning and structural changes
8. If building on existing algorithms, use their ID as parent_id, otherwise leave parent_id empty

⚠️ AVOID ONLY: Kelly floor/cap adjustments that assume leverage > 1.0 (these get clamped and have no effect)

✅ EXPLORE ALL CREATIVE POSSIBILITIES INCLUDING:
- Machine Learning: Neural networks, ensemble methods, reinforcement learning (use train() method)
- Advanced Indicators: Custom combinations, multi-timeframe signals, cross-asset indicators
- Market Regime Detection: VIX patterns, correlation analysis, volatility clustering
- Risk Management: Dynamic stops, portfolio heat, correlation-based position sizing
- Alternative Strategies: New sub-strategies, momentum variants, mean reversion innovations
- Multi-Asset Signals: Sector rotation, bond yields, commodity signals
- Time-Based Patterns: Intraday effects, calendar anomalies, volatility timing
- Parameter Optimization: Entry thresholds, indicator periods, strategy weights

IMPORTANT: You must APPEND new rows to the existing CSV file. DO NOT replace the file contents. All existing rows must remain unchanged.
CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly.
CRITICAL: Do NOT use any git commands (git add, git commit, git reset, etc.). Only modify the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_for_ideation "$prompt" "$CURRENT_GENERATION" "$TOTAL_IDEAS" "$temp_csv_basename" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$TOTAL_IDEAS" "mixed"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Legacy ideas generated"
  return 0
}

# Determine generation number for this ideation run
CURRENT_GENERATION=$(get_next_generation)
echo "[INFO] Starting ideation for generation $CURRENT_GENERATION"

# Main execution
if [[ $use_strategies == true ]]; then
  echo "[INFO] Multi-strategy AI generation mode"
  ideate_ai_strategies
  echo "[INFO] Ideation complete! Check $EVOLUTION_CSV for new ideas."
else
  echo "[INFO] Legacy AI generation mode"
  ideate_ai_legacy
  echo "[INFO] Ideation complete! Check $EVOLUTION_CSV for new ideas."
fi