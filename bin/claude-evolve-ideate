#!/bin/bash

set -e

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../lib/config.sh
source "$SCRIPT_DIR/../lib/config.sh"

# Use CLAUDE_EVOLVE_CONFIG if set, otherwise default
if [[ -n ${CLAUDE_EVOLVE_CONFIG:-} ]]; then
  load_config "$CLAUDE_EVOLVE_CONFIG"
else
  load_config
fi

# Helper function to call AI model (codex o3-pro if available, else Claude)
call_ai_with_limit_check() {
  local prompt="$1"
  local fallback_model="${2:-opus}"
  
  # Check if codex is available
  if command -v codex >/dev/null 2>&1; then
    echo "[INFO] Using codex o3-pro for ideation (smartest available model)" >&2
    
    # Call codex with o3-pro model using -q flag and --full-auto
    local ai_output
    ai_output=$(codex -m o3-pro --full-auto -q "$prompt" 2>&1)
    local ai_exit_code=$?
    
    if [[ $ai_exit_code -eq 0 ]]; then
      echo "$ai_output"
      return 0
    else
      echo "[WARN] Codex failed, falling back to Claude" >&2
    fi
  fi
  
  # Fall back to Claude
  echo "[INFO] Using Claude $fallback_model for ideation" >&2
  
  # Call Claude and capture output
  local claude_output
  claude_output=$(echo "$prompt" | claude --dangerously-skip-permissions --model "$fallback_model" -p 2>&1)
  local claude_exit_code=$?
  
  # Check for usage limit
  if echo "$claude_output" | grep -q "Claude AI usage limit reached"; then
    # Extract timestamp if available
    local limit_timestamp=$(echo "$claude_output" | grep -o "Claude AI usage limit reached|[0-9]*" | cut -d'|' -f2)
    
    # Print red error message
    echo -e "\033[31m[ERROR] CLAUDE AI USAGE LIMIT REACHED!\033[0m" >&2
    echo -e "\033[31m[ERROR] Ideation halted due to API rate limits.\033[0m" >&2
    
    if [[ -n $limit_timestamp ]]; then
      # Convert timestamp to human-readable format
      local limit_date=$(date -r "$limit_timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "Unknown time")
      echo -e "\033[31m[ERROR] Limit will be released at: $limit_date\033[0m" >&2
    fi
    
    echo -e "\033[33m[INFO] Please wait for the rate limit to reset before continuing.\033[0m" >&2
    echo -e "\033[33m[INFO] No ideas were generated. Run ideate again when the limit resets.\033[0m" >&2
    
    exit 1
  fi
  
  # Output Claude's response
  echo "$claude_output"
  
  return $claude_exit_code
}

# Backward compatibility alias
call_claude_with_limit_check() {
  call_ai_with_limit_check "$@"
}

# Parse arguments
use_strategies=true
no_ai=false

while [[ $# -gt 0 ]]; do
  case $1 in
  --help)
    cat <<EOF
claude-evolve ideate - Generate new algorithm ideas using evolutionary strategies

USAGE:
  claude-evolve ideate [--legacy N] [--no-ai]

OPTIONS:
  --legacy N  Use legacy mode with N ideas (ignores strategy config)
  --no-ai     Use manual entry mode instead of AI generation
  --help      Show this help message

DESCRIPTION:
  Generates algorithm ideas using multi-strategy evolutionary approach:
  - Novel exploration: Pure creativity, global search
  - Hill climbing: Parameter tuning of top performers  
  - Structural mutation: Algorithmic changes to top performers
  - Crossover hybrid: Combine successful approaches
  
  Strategy distribution is configured in evolution/config.yaml
EOF
    exit 0
    ;;
  --legacy)
    use_strategies=false
    shift
    if [[ $1 =~ ^[0-9]+$ ]]; then
      TOTAL_IDEAS=$1
      shift
    else
      echo "[ERROR] --legacy requires a number" >&2
      exit 1
    fi
    ;;
  --no-ai)
    no_ai=true
    shift
    ;;
  *)
    echo "[ERROR] Unknown option: $1" >&2
    exit 1
    ;;
  esac
done

# Check workspace using config
if [[ ! -d "$FULL_EVOLUTION_DIR" ]]; then
  echo "[ERROR] Evolution workspace not found: $FULL_EVOLUTION_DIR. Run 'claude-evolve setup' first." >&2
  exit 1
fi

# Ensure CSV exists
if [[ ! -f "$FULL_CSV_PATH" ]]; then
  echo "id,basedOnId,description,performance,status" >"$FULL_CSV_PATH"
fi

# Validate strategy configuration
if [[ $use_strategies == true ]]; then
  total_check=$((NOVEL_EXPLORATION + HILL_CLIMBING + STRUCTURAL_MUTATION + CROSSOVER_HYBRID))
  if [[ $total_check -ne $TOTAL_IDEAS ]]; then
    echo "[ERROR] Strategy counts don't sum to total_ideas ($total_check != $TOTAL_IDEAS)" >&2
    echo "Check your evolution/config.yaml configuration" >&2
    exit 1
  fi
fi

# Get next generation number
get_next_generation() {
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo "01"
    return
  fi
  
  # Find highest generation number
  local max_gen=0
  while IFS=, read -r id rest; do
    # Extract generation number from IDs like "gen01-001"
    if [[ $id =~ ^gen([0-9]+)- ]]; then
      local gen_num=$((10#${BASH_REMATCH[1]}))
      if (( gen_num > max_gen )); then
        max_gen=$gen_num
      fi
    fi
  done < <(tail -n +2 "$FULL_CSV_PATH")
  
  # Increment and format with leading zero
  printf "%02d" $((max_gen + 1))
}

# Get next available ID for current generation
get_next_id() {
  local generation="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo "gen${generation}-001"
    return
  fi
  
  # Find highest ID within this generation
  local max_id=0
  while IFS=, read -r id rest; do
    # Match IDs for this specific generation
    if [[ $id =~ ^gen${generation}-([0-9]+)$ ]]; then
      local id_num=$((10#${BASH_REMATCH[1]}))
      if (( id_num > max_id )); then
        max_id=$id_num
      fi
    fi
  done < <(tail -n +2 "$FULL_CSV_PATH")
  
  # Format next ID with generation and 3-digit number
  printf "gen%s-%03d" "$generation" $((max_id + 1))
}

# Add idea to CSV manually (fallback for manual mode)
add_idea_manual() {
  local description="$1"
  local based_on_id="$2"
  local generation="$3"
  local id
  id=$(get_next_id "$generation")

  # Escape quotes in description
  local escaped_desc="${description//\"/\"\"}"

  # Append to CSV
  echo "${id},${based_on_id},\"${escaped_desc}\",," >>"$FULL_CSV_PATH"
  echo "[INFO] Added idea: $description"
}

# Get top performers for parent selection
get_top_performers() {
  local num_requested="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo ""
    return
  fi
  
  # Use Python to properly parse CSV with quoted fields
  "$PYTHON_CMD" -c "
import csv
import sys

with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader)  # Skip header
    
    completed = []
    for row in reader:
        if len(row) >= 5 and row[3] and row[4] == 'complete':
            try:
                score = float(row[3])
                completed.append((row[0], row[2], score))
            except ValueError:
                pass
    
    # Sort by score descending
    completed.sort(key=lambda x: x[2], reverse=True)
    
    # Output top N
    for i, (id, desc, score) in enumerate(completed[:$num_requested]):
        print(f'{id},{desc},{score}')
"
}

# Manual entry mode
ideate_manual() {
  local ideas_added=0

  for ((i = 1; i <= TOTAL_IDEAS; i++)); do
    if [[ $TOTAL_IDEAS -eq 1 ]]; then
      read -r -p "Enter algorithm idea (or empty to skip): " description
    else
      read -r -p "Enter algorithm idea $i/$TOTAL_IDEAS (or empty to skip): " description
    fi

    if [[ -z $description ]]; then
      echo "[INFO] Empty description, skipping idea"
      continue
    fi

    add_idea_manual "$description" "" "$CURRENT_GENERATION"
    ((ideas_added++))

    if [[ $i -lt $TOTAL_IDEAS ]]; then
      read -r -p "Add another idea? (y/N) " continue_adding
      if [[ $continue_adding != "y" && $continue_adding != "Y" ]]; then
        break
      fi
    fi
  done

  echo "[INFO] Added $ideas_added idea(s) to $EVOLUTION_CSV"
}

# Generate ideas using AI with multi-strategy approach
ideate_ai_strategies() {
  # Check for AI CLI (codex or claude)
  if ! command -v codex >/dev/null 2>&1 && ! command -v claude >/dev/null 2>&1; then
    echo "[WARN] No AI CLI found (codex or claude). Falling back to manual entry."
    return 1
  fi

  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[WARN] $BRIEF_FILE not found. Falling back to manual entry."
    return 1
  fi

  # Get top performers
  local top_performers
  top_performers=$(get_top_performers "$NUM_ELITES")
  
  if [[ -z $top_performers ]]; then
    echo "[INFO] No completed algorithms found, using pure novel exploration"
    # Generate all ideas as novel exploration
    generate_novel_ideas_direct "$TOTAL_IDEAS"
    return 0
  fi

  echo "[INFO] Generating $TOTAL_IDEAS ideas using multi-strategy approach:"
  echo "  Novel exploration: $NOVEL_EXPLORATION"
  echo "  Hill climbing: $HILL_CLIMBING" 
  echo "  Structural mutation: $STRUCTURAL_MUTATION"
  echo "  Crossover hybrid: $CROSSOVER_HYBRID"

  # Generate each type of idea by having Claude directly edit the CSV
  [[ $NOVEL_EXPLORATION -gt 0 ]] && generate_novel_ideas_direct "$NOVEL_EXPLORATION"
  [[ $HILL_CLIMBING -gt 0 ]] && generate_hill_climbing_direct "$HILL_CLIMBING" "$top_performers"
  [[ $STRUCTURAL_MUTATION -gt 0 ]] && generate_structural_mutation_direct "$STRUCTURAL_MUTATION" "$top_performers"
  [[ $CROSSOVER_HYBRID -gt 0 ]] && generate_crossover_direct "$CROSSOVER_HYBRID" "$top_performers"
}

# Generate novel exploration ideas by having Claude edit CSV directly
generate_novel_ideas_direct() {
  local count="$1"
  
  local prompt="Edit the file $FULL_CSV_PATH to add exactly $count new rows for novel algorithmic approaches.

Current CSV content:
$(cat "$FULL_CSV_PATH")

Algorithm files you MUST examine for context:
- Base algorithm: $FULL_ALGORITHM_PATH  
- Evolved algorithms: $FULL_OUTPUT_DIR/evolution_*.py (examine ALL to see what's been tried)

IMPORTANT: Before generating ideas, you should:
1. Read the base algorithm to understand the codebase structure and possibilities
2. Read ALL existing evolution_*.py files to see what modifications have been attempted
3. Analyze the CSV to see which approaches worked (high scores) and which failed
4. Avoid repeating failed approaches unless trying them with significant modifications

Project Brief:
$(cat "$FULL_BRIEF_PATH")

Requirements for new CSV rows:
- IDs must use format: gen$CURRENT_GENERATION-XXX (e.g., gen$CURRENT_GENERATION-001, gen$CURRENT_GENERATION-002)
- Continue numbering from the highest existing ID in generation $CURRENT_GENERATION
- basedOnId should be empty (these are novel approaches) 
- Each description should be one clear sentence describing a specific algorithmic change
- Descriptions should explore completely different approaches than existing ones
- All new rows should have empty performance and status fields
- CRITICAL: You must read existing evolution files to avoid suggesting changes that:
  * Have already been tried and failed
  * Are impossible given the codebase structure
  * Would break the algorithm interface requirements

Example descriptions:
- Use ensemble of 3 random forests with different feature subsets
- Replace neural network with gradient boosting decision trees
- Implement Monte Carlo tree search for feature selection

Add exactly $count rows to the CSV file now."

  echo "[INFO] Generating $count novel exploration ideas..."
  if ! call_ai_with_limit_check "$prompt" "opus"; then
    echo "[WARN] AI failed to generate novel ideas" >&2
    return 1
  fi
  echo "[INFO] Novel exploration ideas generated"
}

# Generate hill climbing ideas by having Claude edit CSV directly
generate_hill_climbing_direct() {
  local count="$1"
  local top_performers="$2"
  
  local prompt="Edit the file $FULL_CSV_PATH to add exactly $count new rows for parameter tuning based on successful algorithms.

Current CSV content:
$(cat "$FULL_CSV_PATH")

Algorithm files you MUST examine for context:
- Base algorithm: $FULL_ALGORITHM_PATH  
- Evolved algorithms: $FULL_OUTPUT_DIR/evolution_*.py (examine ALL to see what's been tried)

IMPORTANT: Before generating ideas, you should:
1. Read the base algorithm to understand the codebase structure and possibilities
2. Read ALL existing evolution_*.py files to see what modifications have been attempted
3. Analyze the CSV to see which approaches worked (high scores) and which failed
4. Avoid repeating failed approaches unless trying them with significant modifications

Successful algorithms to build on:
$top_performers

Project Brief:
$(cat "$FULL_BRIEF_PATH")

Requirements for new CSV rows:
- IDs must use format: gen$CURRENT_GENERATION-XXX (e.g., gen$CURRENT_GENERATION-001, gen$CURRENT_GENERATION-002)
- Continue numbering from the highest existing ID in generation $CURRENT_GENERATION
- basedOnId should reference ONE of the successful algorithm IDs above (pick the best one)
- Each description should be one clear sentence about parameter tuning
- Focus on adjusting hyperparameters, thresholds, sizes, learning rates
- All new rows should have empty performance and status fields
- CRITICAL: You must read the parent algorithm file to understand:
  * What parameters are actually tunable in the code
  * What changes made this algorithm successful vs its parent
  * What parameter ranges make sense given the implementation

Example descriptions:
- Increase learning rate from 0.001 to 0.01 for faster convergence
- Reduce batch size from 32 to 16 to improve gradient estimates
- Set dropout rate to 0.3 instead of 0.1 to prevent overfitting

Add exactly $count parameter tuning rows to the CSV file now."

  echo "[INFO] Generating $count hill climbing ideas..."
  if ! call_ai_with_limit_check "$prompt" "opus"; then
    echo "[WARN] AI failed to generate hill climbing ideas" >&2
    return 1
  fi
  echo "[INFO] Hill climbing ideas generated"
}

# Generate structural mutation ideas by having Claude edit CSV directly
generate_structural_mutation_direct() {
  local count="$1"
  local top_performers="$2"
  
  local prompt="Edit the file $FULL_CSV_PATH to add exactly $count new rows for structural modifications based on successful algorithms.

Current CSV content:
$(cat "$FULL_CSV_PATH")

Algorithm files you MUST examine for context:
- Base algorithm: $FULL_ALGORITHM_PATH  
- Evolved algorithms: $FULL_OUTPUT_DIR/evolution_*.py (examine ALL to see what's been tried)

IMPORTANT: Before generating ideas, you should:
1. Read the base algorithm to understand the codebase structure and possibilities
2. Read ALL existing evolution_*.py files to see what modifications have been attempted
3. Analyze the CSV to see which approaches worked (high scores) and which failed
4. Avoid repeating failed approaches unless trying them with significant modifications

Successful algorithms to build on:
$top_performers

Project Brief:
$(cat "$FULL_BRIEF_PATH")

Requirements for new CSV rows:
- IDs must use format: gen$CURRENT_GENERATION-XXX (e.g., gen$CURRENT_GENERATION-001, gen$CURRENT_GENERATION-002)
- Continue numbering from the highest existing ID in generation $CURRENT_GENERATION
- basedOnId should reference ONE of the successful algorithm IDs above (pick the best one)
- Each description should be one clear sentence about architectural changes
- Keep core insights but change implementation approach
- All new rows should have empty performance and status fields
- CRITICAL: You must read the parent algorithm file to understand:
  * What structural elements can be modified within the codebase constraints
  * What architectural decisions led to this algorithm's success
  * Which components are essential vs which can be replaced

Example descriptions:
- Replace linear layers with convolutional layers for spatial feature learning
- Use bidirectional LSTM instead of unidirectional for better context
- Add residual connections between layers to improve gradient flow

Add exactly $count structural modification rows to the CSV file now."

  echo "[INFO] Generating $count structural mutation ideas..."
  if ! call_ai_with_limit_check "$prompt" "opus"; then
    echo "[WARN] AI failed to generate structural mutation ideas" >&2
    return 1
  fi
  echo "[INFO] Structural mutation ideas generated"
}

# Generate crossover hybrid ideas by having Claude edit CSV directly
generate_crossover_direct() {
  local count="$1"
  local top_performers="$2"
  
  local prompt="Edit the file $FULL_CSV_PATH to add exactly $count new rows for hybrid combinations of successful algorithms.

Current CSV content:
$(cat "$FULL_CSV_PATH")

Algorithm files you MUST examine for context:
- Base algorithm: $FULL_ALGORITHM_PATH  
- Evolved algorithms: $FULL_OUTPUT_DIR/evolution_*.py (examine ALL to see what's been tried)

IMPORTANT: Before generating ideas, you should:
1. Read the base algorithm to understand the codebase structure and possibilities
2. Read ALL existing evolution_*.py files to see what modifications have been attempted
3. Analyze the CSV to see which approaches worked (high scores) and which failed
4. Avoid repeating failed approaches unless trying them with significant modifications

Top performers to combine:
$top_performers

Project Brief:
$(cat "$FULL_BRIEF_PATH")

Requirements for new CSV rows:
- IDs must use format: gen$CURRENT_GENERATION-XXX (e.g., gen$CURRENT_GENERATION-001, gen$CURRENT_GENERATION-002)
- Continue numbering from the highest existing ID in generation $CURRENT_GENERATION
- basedOnId should reference ONE of the successful algorithm IDs above (pick the best one as base)
- Each description should be one clear sentence combining elements from different algorithms
- Be specific about what elements to merge
- All new rows should have empty performance and status fields
- CRITICAL: You must read the relevant algorithm files to:
  * Identify the specific improvements that made each algorithm successful
  * Understand which components are compatible for merging
  * Ensure the combined approach is technically feasible in the codebase

Example descriptions:
- Combine ensemble voting from algorithm 3 with feature selection from algorithm 5
- Use the attention mechanism from algorithm 2 with the optimizer from algorithm 4
- Merge the preprocessing pipeline from algorithm 1 with the architecture from algorithm 6

Add exactly $count hybrid combination rows to the CSV file now."

  echo "[INFO] Generating $count crossover hybrid ideas..."
  if ! call_ai_with_limit_check "$prompt" "opus"; then
    echo "[WARN] AI failed to generate crossover ideas" >&2
    return 1
  fi
  echo "[INFO] Crossover hybrid ideas generated"
}

# Legacy AI generation mode (for backward compatibility)
ideate_ai_legacy() {
  # Check for AI CLI (codex or claude)
  if ! command -v codex >/dev/null 2>&1 && ! command -v claude >/dev/null 2>&1; then
    echo "[WARN] No AI CLI found (codex or claude). Falling back to manual entry."
    return 1
  fi

  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[WARN] $BRIEF_FILE not found. Falling back to manual entry."
    return 1
  fi

  # Get top performers (pure shell)
  local top_performers=""
  if [[ -f "$FULL_CSV_PATH" ]]; then
    # Simple top performers extraction (lines with non-empty performance)
    top_performers=$(awk -F, 'NR > 1 && $4 != "" { print $1 ": " $3 " (score: " $4 ")" }' "$FULL_CSV_PATH" | head -5)
  fi

  # Build prompt
  local prompt="Edit the file $FULL_CSV_PATH to add exactly $TOTAL_IDEAS new algorithm variation rows.

Current CSV content:
$(cat "$FULL_CSV_PATH")

Algorithm files you MUST examine for context:
- Base algorithm: $FULL_ALGORITHM_PATH  
- Evolved algorithms: $FULL_OUTPUT_DIR/evolution_*.py (examine ALL to see what's been tried)

IMPORTANT: Before generating ideas, you should:
1. Read the base algorithm to understand the codebase structure and possibilities
2. Read ALL existing evolution_*.py files to see what modifications have been attempted
3. Analyze the CSV to see which approaches worked (high scores) and which failed
4. Avoid repeating failed approaches unless trying them with significant modifications

Project Brief:
$(cat "$FULL_BRIEF_PATH")"

  if [[ -n $top_performers ]]; then
    prompt+="

Top Performing Algorithms So Far:
$top_performers"
  fi

  prompt+="

Requirements for new CSV rows:
- IDs must use format: gen$CURRENT_GENERATION-XXX (e.g., gen$CURRENT_GENERATION-001, gen$CURRENT_GENERATION-002)
- Continue numbering from the highest existing ID in generation $CURRENT_GENERATION
- basedOnId should be empty or reference existing algorithm ID
- Each description should be one clear sentence describing an algorithmic approach
- All new rows should have empty performance and status fields

Add exactly $TOTAL_IDEAS algorithm variation rows to the CSV file now."

  echo "[INFO] Generating $TOTAL_IDEAS ideas (legacy mode)..."
  if ! call_ai_with_limit_check "$prompt" "opus"; then
    echo "[WARN] AI failed to generate ideas" >&2
    return 1
  fi
  echo "[INFO] Legacy ideas generated"
}

# Determine generation number for this ideation run
CURRENT_GENERATION=$(get_next_generation)
echo "[INFO] Starting ideation for generation $CURRENT_GENERATION"

# Main execution
if [[ $no_ai == true ]]; then
  echo "[INFO] Manual entry mode"
  ideate_manual
elif [[ $use_strategies == true ]]; then
  echo "[INFO] Multi-strategy AI generation mode"
  if ! ideate_ai_strategies; then
    echo "[INFO] Falling back to manual entry"
    ideate_manual
  fi
else
  echo "[INFO] Legacy AI generation mode"
  if ! ideate_ai_legacy; then
    echo "[INFO] Falling back to manual entry" 
    ideate_manual
  fi
fi