#!/bin/bash

set -e

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../lib/config.sh
source "$SCRIPT_DIR/../lib/config.sh"

# Use CLAUDE_EVOLVE_CONFIG if set, otherwise default
if [[ -n ${CLAUDE_EVOLVE_CONFIG:-} ]]; then
  load_config "$CLAUDE_EVOLVE_CONFIG"
else
  load_config
fi

# Function to determine which model to use based on generation
get_model_for_generation() {
  local generation="$1"
  local gen_num
  
  # Extract numeric part of generation (e.g., "05" from gen05)
  if [[ $generation =~ ^0*([0-9]+)$ ]]; then
    gen_num=$((10#${BASH_REMATCH[1]}))
  else
    gen_num=1  # Default for malformed input
  fi
  
  # Check which AI tools are available
  local has_o3=false
  local has_gemini=false
  
  if command -v codex >/dev/null 2>&1; then
    has_o3=true
  fi
  
  if command -v gemini >/dev/null 2>&1; then
    has_gemini=true
  fi
  
  # Determine rotation based on what's available
  if [[ "$has_o3" == "true" && "$has_gemini" == "true" ]]; then
    # All three available: opus -> o3 -> gemini rotation
    case $((gen_num % 3)) in
      1) echo "opus" ;;     # 1, 4, 7, 10...
      2) echo "o3" ;;       # 2, 5, 8, 11...
      0) echo "gemini" ;;   # 3, 6, 9, 12...
    esac
  elif [[ "$has_o3" == "true" ]]; then
    # Only opus and o3: alternate between them
    if (( gen_num % 2 == 1 )); then
      echo "opus"    # Odd generations
    else
      echo "o3"      # Even generations
    fi
  elif [[ "$has_gemini" == "true" ]]; then
    # Only opus and gemini: alternate between them
    if (( gen_num % 2 == 1 )); then
      echo "opus"    # Odd generations
    else
      echo "gemini" # Even generations
    fi
  else
    # Only opus available
    echo "opus"
  fi
}

# Helper function to call AI model (alternating based on generation)
call_ai_with_limit_check() {
  local prompt="$1"
  local generation="${2:-01}"  # Default to generation 01 if not provided
  
  # Determine which model to use for this generation
  local preferred_model
  preferred_model=$(get_model_for_generation "$generation")
  
  echo "[INFO] Generation $generation: Using $preferred_model" >&2
  
  # Try preferred model first
  if [[ "$preferred_model" == "o3" ]] && command -v codex >/dev/null 2>&1; then
    echo "[INFO] Using codex o3 for ideation" >&2
    
    # Call codex with o3 model using exec subcommand
    local ai_output
    ai_output=$(echo "$prompt" | codex exec -m o3 --full-auto 2>&1)
    local ai_exit_code=$?
    
    if [[ $ai_exit_code -eq 0 ]]; then
      # Clean o3 output - it may be JSON with the response in a field
      local cleaned_output
      # Try to extract content from JSON response if present
      if echo "$ai_output" | grep -q '"content"'; then
        # Attempt to extract content field from JSON
        cleaned_output=$(echo "$ai_output" | python3 -c "
import sys
import json
try:
    data = json.load(sys.stdin)
    if 'content' in data:
        print(data['content'])
    elif 'response' in data:
        print(data['response'])
    elif 'text' in data:
        print(data['text'])
    else:
        # If no known field, print the whole thing
        print(json.dumps(data))
except:
    # If not valid JSON, print as-is
    print(sys.stdin.read())
" 2>/dev/null || echo "$ai_output")
      else
        cleaned_output="$ai_output"
      fi
      
      # Validate the output is not empty and doesn't contain error messages
      if [[ -n "$cleaned_output" ]] && ! echo "$cleaned_output" | grep -q "error\|failed\|exception"; then
        echo "$cleaned_output"
        return 0
      else
        echo "[WARN] Codex o3 returned invalid output, falling back to Claude Opus" >&2
        preferred_model="opus"
      fi
    else
      echo "[WARN] Codex o3 failed with exit code $ai_exit_code, falling back to Claude Opus" >&2
      preferred_model="opus"
    fi
  elif [[ "$preferred_model" == "gemini" ]] && command -v gemini >/dev/null 2>&1; then
    echo "[INFO] Using gemini 2.5 pro for ideation" >&2
    
    # Call gemini with -y and -p flags
    local ai_output
    ai_output=$(gemini -y -p "$prompt" 2>&1)
    local ai_exit_code=$?
    
    if [[ $ai_exit_code -eq 0 ]]; then
      # Check for authentication messages or other non-response content
      if echo "$ai_output" | grep -q "Attempting to authenticate\|Authenticating\|Loading\|Initializing"; then
        echo "[WARN] Gemini is still authenticating, falling back to Claude Opus" >&2
        preferred_model="opus"
      elif [[ -z "$ai_output" ]] || [[ $(echo "$ai_output" | wc -l) -lt 2 ]]; then
        echo "[WARN] Gemini returned insufficient output, falling back to Claude Opus" >&2
        preferred_model="opus"
      else
        echo "$ai_output"
        return 0
      fi
    else
      echo "[WARN] Gemini failed with exit code $ai_exit_code, falling back to Claude Opus" >&2
      preferred_model="opus"
    fi
  fi
  
  # Use Claude with preferred model (or fallback)
  echo "[INFO] Using Claude $preferred_model for ideation" >&2
  
  # Call Claude and capture output
  local claude_output
  claude_output=$(echo "$prompt" | claude --dangerously-skip-permissions --model "$preferred_model" -p 2>&1)
  local claude_exit_code=$?
  
  # Check for usage limit
  if echo "$claude_output" | grep -q "Claude AI usage limit reached"; then
    # Extract timestamp if available
    local limit_timestamp=$(echo "$claude_output" | grep -o "Claude AI usage limit reached|[0-9]*" | cut -d'|' -f2)
    
    # Print red error message
    echo -e "\033[31m[ERROR] CLAUDE AI USAGE LIMIT REACHED!\033[0m" >&2
    echo -e "\033[31m[ERROR] Ideation halted due to API rate limits.\033[0m" >&2
    
    if [[ -n $limit_timestamp ]]; then
      # Convert timestamp to human-readable format
      local limit_date=$(date -r "$limit_timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "Unknown time")
      echo -e "\033[31m[ERROR] Limit will be released at: $limit_date\033[0m" >&2
    fi
    
    echo -e "\033[33m[INFO] Please wait for the rate limit to reset before continuing.\033[0m" >&2
    echo -e "\033[33m[INFO] No ideas were generated. Run ideate again when the limit resets.\033[0m" >&2
    
    exit 1
  fi
  
  # Validate output doesn't contain shell constructs that could corrupt CSV
  if echo "$claude_output" | grep -E "EOF.*<.*null|<<.*EOF|<.*dev.*null" >/dev/null 2>&1; then
    echo "[ERROR] AI output contains invalid shell constructs" >&2
    echo "[DEBUG] Problematic output: $claude_output" | head -5 >&2
    return 1
  fi
  
  # Output Claude's response
  echo "$claude_output"
  
  return $claude_exit_code
}

# Backward compatibility alias
call_claude_with_limit_check() {
  call_ai_with_limit_check "$@"
}

# Robust AI calling with fallbacks across all available models
call_ai_with_fallbacks() {
  local prompt="$1"
  local generation="${2:-01}"
  
  # Determine which model to use based on generation (round-robin)
  local gen_num
  if [[ $generation =~ ^0*([0-9]+)$ ]]; then
    gen_num=$((10#${BASH_REMATCH[1]}))
  else
    gen_num=1
  fi
  
  # Check which AI tools are available
  local available_models=()
  if command -v codex >/dev/null 2>&1; then
    available_models+=("o3")
  fi
  if command -v gemini >/dev/null 2>&1; then
    available_models+=("gemini")
  fi
  available_models+=("opus")  # Claude Opus always available
  
  # Create ordered list based on round-robin for this generation
  local num_models=${#available_models[@]}
  local start_index=$((gen_num % num_models))
  local models=()
  
  # Add models in round-robin order starting from the calculated index
  for ((i=0; i<num_models; i++)); do
    local idx=$(((start_index + i) % num_models))
    models+=("${available_models[$idx]}")
  done
  
  echo "[INFO] Model order for generation $generation (round-robin): ${models[*]}" >&2
  
  # Try each model in the ordered sequence
  for model in "${models[@]}"; do
    echo "[INFO] Trying $model for ideation" >&2
    
    local ai_output
    local ai_exit_code
    
    if [[ "$model" == "o3" ]] && command -v codex >/dev/null 2>&1; then
      ai_output=$(echo "$prompt" | codex exec -m o3 --full-auto 2>&1)
      ai_exit_code=$?
      
      if [[ $ai_exit_code -eq 0 ]]; then
        # Clean o3 output like in the original function
        if echo "$ai_output" | grep -q '"content"'; then
          ai_output=$(echo "$ai_output" | python3 -c "
import sys
import json
try:
    data = json.load(sys.stdin)
    if 'content' in data:
        print(data['content'])
    elif 'response' in data:
        print(data['response'])
    elif 'text' in data:
        print(data['text'])
    else:
        print(json.dumps(data))
except:
    print(sys.stdin.read())
" 2>/dev/null || echo "$ai_output")
        fi
        
        if [[ -n "$ai_output" ]] && ! echo "$ai_output" | grep -q "error\|failed\|exception"; then
          echo "$ai_output"
          return 0
        fi
      fi
      
    elif [[ "$model" == "gemini" ]] && command -v gemini >/dev/null 2>&1; then
      ai_output=$(gemini -y -p "$prompt" 2>&1)
      ai_exit_code=$?
      
      if [[ $ai_exit_code -eq 0 ]]; then
        if ! echo "$ai_output" | grep -q "Attempting to authenticate\|Authenticating\|Loading\|Initializing"; then
          if [[ -n "$ai_output" ]] && [[ $(echo "$ai_output" | wc -l) -ge 2 ]]; then
            echo "$ai_output"
            return 0
          fi
        fi
      fi
      
    else
      # Use Claude with the specified model
      ai_output=$(echo "$prompt" | claude --dangerously-skip-permissions --model "$model" -p 2>&1)
      ai_exit_code=$?
      
      if [[ $ai_exit_code -eq 0 ]]; then
        # Check for usage limits
        if ! echo "$ai_output" | grep -q "Claude AI usage limit reached"; then
          if ! echo "$ai_output" | grep -E "EOF.*<.*null|<<.*EOF|<.*dev.*null" >/dev/null 2>&1; then
            echo "$ai_output"
            return 0
          fi
        fi
      fi
    fi
    
    echo "[WARN] $model failed or returned unusable output, trying next model..." >&2
  done
  
  echo "[ERROR] All AI models failed to generate usable output" >&2
  return 1
}

# Parse arguments
use_strategies=true

while [[ $# -gt 0 ]]; do
  case $1 in
  --help)
    cat <<EOF
claude-evolve ideate - Generate new algorithm ideas using evolutionary strategies

USAGE:
  claude-evolve ideate [--legacy N]

OPTIONS:
  --legacy N  Use legacy mode with N ideas (ignores strategy config)
  --help      Show this help message

DESCRIPTION:
  Generates algorithm ideas using multi-strategy evolutionary approach:
  - Novel exploration: Pure creativity, global search
  - Hill climbing: Parameter tuning of top performers  
  - Structural mutation: Algorithmic changes to top performers
  - Crossover hybrid: Combine successful approaches
  
  Strategy distribution is configured in evolution/config.yaml
EOF
    exit 0
    ;;
  --legacy)
    use_strategies=false
    shift
    if [[ $1 =~ ^[0-9]+$ ]]; then
      TOTAL_IDEAS=$1
      shift
    else
      echo "[ERROR] --legacy requires a number" >&2
      exit 1
    fi
    ;;
  *)
    echo "[ERROR] Unknown option: $1" >&2
    exit 1
    ;;
  esac
done

# Check workspace using config
if [[ ! -d "$FULL_EVOLUTION_DIR" ]]; then
  echo "[ERROR] Evolution workspace not found: $FULL_EVOLUTION_DIR. Run 'claude-evolve setup' first." >&2
  exit 1
fi

# Ensure CSV exists
if [[ ! -f "$FULL_CSV_PATH" ]]; then
  echo "id,basedOnId,description,performance,status" >"$FULL_CSV_PATH"
fi

# Validate strategy configuration
if [[ $use_strategies == true ]]; then
  total_check=$((NOVEL_EXPLORATION + HILL_CLIMBING + STRUCTURAL_MUTATION + CROSSOVER_HYBRID))
  if [[ $total_check -ne $TOTAL_IDEAS ]]; then
    echo "[ERROR] Strategy counts don't sum to total_ideas ($total_check != $TOTAL_IDEAS)" >&2
    echo "Check your evolution/config.yaml configuration" >&2
    exit 1
  fi
fi

# Get next generation number
get_next_generation() {
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo "01"
    return
  fi
  
  # Use Python for proper CSV parsing
  local max_gen
  max_gen=$("$PYTHON_CMD" -c "
import csv
max_gen = 0
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            id_field = row[0].strip()
            if id_field.startswith('gen') and '-' in id_field:
                try:
                    gen_part = id_field.split('-')[0]  # e.g., 'gen01'
                    gen_num = int(gen_part[3:])  # Extract number after 'gen'
                    max_gen = max(max_gen, gen_num)
                except (ValueError, IndexError):
                    pass
print(max_gen)
")
  
  # Increment and format with leading zero
  printf "%02d" $((max_gen + 1))
}

# This function is no longer used with direct CSV modification approach
# Keeping for backward compatibility but it's not called anywhere
get_next_id_number() {
  "$PYTHON_CMD" -c "
import csv
import re
max_id = 0
pattern = re.compile(r'^gen$CURRENT_GENERATION-(\d+)$')
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            match = pattern.match(row[0].strip())
            if match:
                max_id = max(max_id, int(match.group(1)))
print(max_id + 1)
"
}

# Validate that AI directly modified the CSV file
validate_direct_csv_modification() {
  local temp_csv="$1"
  local expected_count="$2"
  local idea_type="$3"
  
  # Check if the file was actually modified
  if [[ ! -f "$temp_csv" ]]; then
    echo "[ERROR] CSV file was not found after AI modification" >&2
    return 1
  fi
  
  # Validate the modified CSV has more entries than original
  # Count actual data rows (excluding header and empty lines)
  local original_count
  original_count=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  local new_count
  new_count=$(grep -v '^[[:space:]]*$' "$temp_csv" | tail -n +2 | wc -l)
  
  echo "[DEBUG] Original CSV data rows: $original_count" >&2
  echo "[DEBUG] Modified CSV data rows: $new_count" >&2
  echo "[DEBUG] Expected to add: $expected_count ideas" >&2
  
  if [[ $new_count -le $original_count ]]; then
    echo "[ERROR] CSV file wasn't modified - same number of data rows ($new_count <= $original_count)" >&2
    echo "[DEBUG] First 10 lines of CSV after AI attempt:" >&2
    head -10 "$temp_csv" >&2
    return 1
  fi
  
  local added_count=$((new_count - original_count))
  if [[ $added_count -ne $expected_count ]]; then
    echo "[WARN] Expected to add $expected_count ideas but added $added_count" >&2
  fi
  
  # Replace original CSV with modified version
  mv "$temp_csv" "$FULL_CSV_PATH"
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  return 0
}

# DEPRECATED: Old validation function for CSV output approach
validate_and_apply_csv_modification_old() {
  local modified_csv="$1"
  local temp_csv="$2"
  local expected_count="$3"
  local idea_type="$4"
  
  # Check if the response looks like an error message (but not if it's just CSV data containing these words)
  if echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    # This looks like a CSV file, not an error message
    echo "[DEBUG] AI returned what appears to be a CSV file" >&2
  elif echo "$modified_csv" | grep -qi "error\|failed\|limit\|exceeded\|sorry\|cannot\|unable"; then
    echo "[ERROR] AI failed to modify CSV and returned an error message:" >&2
    echo "$modified_csv" | head -200 >&2
    return 1
  fi
  
  # Check if response is too short to be a valid CSV
  if [[ ${#modified_csv} -lt 50 ]]; then
    echo "[ERROR] AI response is too short to be a valid CSV (${#modified_csv} chars):" >&2
    echo "$modified_csv" >&2
    return 1
  fi
  
  # Extract CSV from AI output (in case there's extra text before it)
  local csv_start_line
  csv_start_line=$(echo "$modified_csv" | grep -n "id,basedOnId,description,performance,status" | head -1 | cut -d: -f1)
  
  if [[ -n "$csv_start_line" ]]; then
    # Extract CSV starting from the header line
    modified_csv=$(echo "$modified_csv" | tail -n +$csv_start_line)
    echo "[DEBUG] Found CSV header at line $csv_start_line, extracting from there" >&2
  elif ! echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    echo "[ERROR] AI failed to return a valid CSV file. Expected CSV with header, but got:" >&2
    echo "$modified_csv" | head -c 500 >&2
    echo "" >&2
    echo "[DEBUG] The AI was asked to output the complete modified CSV but didn't" >&2
    return 1
  fi
  
  # Write the modified CSV to temp file
  echo "$modified_csv" > "$temp_csv"
  
  # Validate the modified CSV has more entries than original
  local original_count
  original_count=$(wc -l < "$FULL_CSV_PATH")
  local new_count
  new_count=$(wc -l < "$temp_csv")
  
  echo "[DEBUG] Original CSV line count: $original_count" >&2
  echo "[DEBUG] Modified CSV line count: $new_count" >&2
  echo "[DEBUG] Expected to add: $expected_count ideas" >&2
  
  if [[ $new_count -le $original_count ]]; then
    echo "[ERROR] Modified CSV doesn't have more entries ($new_count <= $original_count)" >&2
    echo "[DEBUG] First 10 lines of modified CSV:" >&2
    head -10 "$temp_csv" >&2
    return 1
  fi
  
  local added_count=$((new_count - original_count))
  if [[ $added_count -ne $expected_count ]]; then
    echo "[WARN] Expected to add $expected_count ideas but added $added_count" >&2
  fi
  
  # Replace original CSV with modified version
  mv "$temp_csv" "$FULL_CSV_PATH"
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  return 0
}

# DEPRECATED: Old two-step process function - kept for reference
process_ai_ideas_direct_old() {
  local count="$1"
  local idea_type="$2"  # novel, hill-climbing, structural, crossover
  local top_performers="${3:-}"  # Optional, for non-novel ideas
  local ai_output="$4"  # The AI's response with ideas
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[DEBUG] Starting CSV modification for $count $idea_type ideas" >&2
  echo "[DEBUG] Original CSV path: $FULL_CSV_PATH" >&2
  echo "[DEBUG] Temp CSV path: $temp_csv" >&2
  echo "[DEBUG] Original CSV size: $(wc -l < "$FULL_CSV_PATH") lines" >&2
  
  # Build prompt for AI to directly modify the CSV
  local csv_prompt="I need you to add exactly $count new $idea_type ideas to this CSV file.

Here are the $count $idea_type ideas to add:
$ai_output

Current CSV contents:
$(cat "$temp_csv")

Instructions:
1. Add exactly $count new rows to the CSV
2. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
3. For each idea, create a row with: id,parent_id,description,,pending
4. For novel ideas: leave parent_id empty
5. For other idea types: use appropriate parent IDs from these top performers:
$top_performers

IMPORTANT: Output the complete modified CSV file. Do not add any explanation or other text - just output the CSV."
  
  echo "[INFO] Having AI directly modify CSV with $count $idea_type ideas..."
  
  # Get AI to modify the CSV with fallbacks
  local modified_csv
  local stderr_file="/tmp/claude-evolve-stderr-$$.txt"
  if ! modified_csv=$(call_ai_with_fallbacks "$csv_prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to modify CSV" >&2
    cat "$stderr_file" >&2
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Check if the response looks like an error message
  if echo "$modified_csv" | grep -qi "error\|failed\|limit\|exceeded\|sorry\|cannot\|unable"; then
    echo "[ERROR] AI failed to modify CSV and returned an error message:" >&2
    echo "$modified_csv" | head -200 >&2
    rm -f "$temp_csv" 
    return 1
  fi
  
  # Check if response is too short to be a valid CSV
  if [[ ${#modified_csv} -lt 50 ]]; then
    echo "[ERROR] AI response is too short to be a valid CSV (${#modified_csv} chars):" >&2
    echo "$modified_csv" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Extract CSV from AI output (in case there's extra text before it)
  local csv_start_line
  csv_start_line=$(echo "$modified_csv" | grep -n "id,basedOnId,description,performance,status" | head -1 | cut -d: -f1)
  
  if [[ -n "$csv_start_line" ]]; then
    # Extract CSV starting from the header line
    modified_csv=$(echo "$modified_csv" | tail -n +$csv_start_line)
    echo "[DEBUG] Found CSV header at line $csv_start_line, extracting from there" >&2
  elif ! echo "$modified_csv" | head -1 | grep -q "id,basedOnId,description,performance,status"; then
    echo "[ERROR] AI failed to return a valid CSV file. Expected CSV with header, but got:" >&2
    echo "$modified_csv" | head -c 500 >&2
    echo "" >&2
    echo "[DEBUG] The AI was asked to output the complete modified CSV but didn't" >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  # Write the modified CSV to temp file
  echo "$modified_csv" > "$temp_csv"
  
  # Debug: Show the AI's CSV modification attempt
  echo "[DEBUG] AI response length: ${#modified_csv} characters" >&2
  echo "[DEBUG] First 300 chars of AI response:" >&2
  echo "$modified_csv" | head -c 300 >&2
  echo "" >&2
  echo "[DEBUG] Last 300 chars of AI response:" >&2
  echo "$modified_csv" | tail -c 300 >&2
  echo "" >&2
  
  # Validate the modified CSV has more entries than original
  local original_count
  original_count=$(wc -l < "$FULL_CSV_PATH")
  local new_count
  new_count=$(wc -l < "$temp_csv")
  
  echo "[DEBUG] Original CSV line count: $original_count" >&2
  echo "[DEBUG] Modified CSV line count: $new_count" >&2
  echo "[DEBUG] Expected to add: $count ideas" >&2
  
  if [[ $new_count -le $original_count ]]; then
    echo "[ERROR] Modified CSV doesn't have more entries ($new_count <= $original_count)" >&2
    echo "[DEBUG] Temp CSV contents:" >&2
    cat "$temp_csv" | head -10 >&2
    echo "[DEBUG] Original CSV contents:" >&2
    cat "$FULL_CSV_PATH" | head -10 >&2
    rm -f "$temp_csv"
    return 1
  fi
  
  local added_count=$((new_count - original_count))
  if [[ $added_count -ne $count ]]; then
    echo "[WARN] Expected to add $count ideas but added $added_count" >&2
  fi
  
  # Replace original CSV with modified version
  mv "$temp_csv" "$FULL_CSV_PATH"
  
  echo "[INFO] Successfully added $added_count $idea_type ideas to CSV"
  
  return 0
}

# Get next available ID for current generation
get_next_id() {
  local generation="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo "gen${generation}-001"
    return
  fi
  
  # Use Python for proper CSV parsing
  local max_id
  max_id=$("$PYTHON_CMD" -c "
import csv
import re
max_id = 0
pattern = re.compile(r'^gen${generation}-(\d+)$')
with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader, None)  # Skip header
    for row in reader:
        if row and len(row) > 0:
            id_field = row[0].strip()
            match = pattern.match(id_field)
            if match:
                id_num = int(match.group(1))
                max_id = max(max_id, id_num)
print(max_id)
")
  
  # Format next ID with generation and 3-digit number
  printf "gen%s-%03d" "$generation" $((max_id + 1))
}


# Get top performers for parent selection (absolute + top novel candidates)
get_top_performers() {
  local num_requested="$1"
  if [[ ! -f "$FULL_CSV_PATH" ]]; then
    echo ""
    return
  fi
  
  # Use Python to properly parse CSV and find top performers + top novel candidates
  "$PYTHON_CMD" -c "
import csv
import sys

with open('$FULL_CSV_PATH', 'r') as f:
    reader = csv.reader(f)
    next(reader)  # Skip header
    
    completed = []
    novel = []
    
    # Collect all completed candidates
    for row in reader:
        if len(row) >= 5 and row[3] and row[4] == 'complete':
            try:
                candidate_id = row[0]
                parent_id = row[1] if len(row) > 1 else ''
                description = row[2] if len(row) > 2 else ''
                score = float(row[3])
                
                completed.append((candidate_id, description, score))
                
                # Track novel candidates separately
                if not parent_id:
                    novel.append((candidate_id, description, score))
                    
            except ValueError:
                pass
    
    # Sort absolute leaders by score (descending)
    completed.sort(key=lambda x: x[2], reverse=True)
    
    # Sort novel candidates by score (descending)
    novel.sort(key=lambda x: x[2], reverse=True)
    
    # Collect top performers
    selected_ids = set()
    results = []
    
    # Add top absolute performers
    for i, (candidate_id, description, score) in enumerate(completed[:$num_requested]):
        results.append(f'{candidate_id},{description},{score}')
        selected_ids.add(candidate_id)
    
    # Add top novel candidates (if not already selected)
    novel_count = 0
    for candidate_id, description, score in novel:
        if candidate_id not in selected_ids and novel_count < $NUM_REVOLUTION:
            results.append(f'{candidate_id},{description},{score}')
            selected_ids.add(candidate_id)
            novel_count += 1
    
    # Output all selected candidates
    for result in results:
        print(result)
"
}



# Generate ideas using AI with multi-strategy approach
ideate_ai_strategies() {
  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[ERROR] $BRIEF_FILE not found. Run 'claude-evolve setup' first." >&2
    exit 1
  fi

  # Baseline should already be evaluated by run command

  # Get top performers (now includes top novel candidates)
  local top_performers
  top_performers=$(get_top_performers "$NUM_ELITES")
  
  if [[ -z $top_performers ]]; then
    echo "[INFO] No completed algorithms found, will use baseline algorithm for hill climbing"
    # For hill climbing and mutations, use the baseline algorithm
    # Use a special ID that validation script will recognize
    top_performers="000,Baseline Algorithm (algorithm.py),0.0"
  fi

  echo "[INFO] Generating $TOTAL_IDEAS ideas using multi-strategy approach:"
  echo "  Novel exploration: $NOVEL_EXPLORATION"
  echo "  Hill climbing: $HILL_CLIMBING" 
  echo "  Structural mutation: $STRUCTURAL_MUTATION"
  echo "  Crossover hybrid: $CROSSOVER_HYBRID"

  # Generate each type of idea by having Claude directly edit the CSV
  [[ $NOVEL_EXPLORATION -gt 0 ]] && generate_novel_ideas_direct "$NOVEL_EXPLORATION"
  [[ $HILL_CLIMBING -gt 0 ]] && generate_hill_climbing_direct "$HILL_CLIMBING" "$top_performers"
  [[ $STRUCTURAL_MUTATION -gt 0 ]] && generate_structural_mutation_direct "$STRUCTURAL_MUTATION" "$top_performers"
  [[ $CROSSOVER_HYBRID -gt 0 ]] && generate_crossover_direct "$CROSSOVER_HYBRID" "$top_performers"
}

# Generate novel exploration ideas using direct CSV modification
generate_novel_ideas_direct() {
  local count="$1"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count novel exploration ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $count novel algorithmic ideas to the CSV file: $temp_csv_basename

Current evolution context:
- Generation: $CURRENT_GENERATION
- Algorithm: algorithm.py (base algorithm)
- Brief: $(head -20 "$FULL_BRIEF_PATH")

Instructions:
1. Use the Read tool to examine the current CSV file
2. Use the Edit or MultiEdit tool to add exactly $count new rows to the CSV file
3. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
4. For each idea, create a row with: id,,description,,pending (empty parent_id for novel ideas)
5. Each description should be one clear sentence describing a novel algorithmic approach
6. Focus on creative, ambitious ideas that haven't been tried yet
7. Consider machine learning, new indicators, regime detection, risk management, etc.

CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_with_fallbacks "$prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate novel ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "novel"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Novel exploration ideas generated successfully"
  return 0
}

# Generate hill climbing ideas using direct CSV modification
generate_hill_climbing_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count hill climbing ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $count parameter tuning ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use one of these exact parent IDs: $valid_parent_ids

Successful algorithms to tune:
$top_performers

CRITICAL INSTRUCTION: Before generating parameter tuning ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

Instructions:
1. Use the Read tool to examine the current CSV file
2. Use the Edit or MultiEdit tool to add exactly $count new rows to the CSV file
3. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
4. For each idea, create a row with: id,parent_id,description,,pending
5. Each parent_id MUST be one of: $valid_parent_ids
6. Each description should focus on adjusting specific parameters that exist in the parent's source code
7. Include current and new parameter values (e.g., \"Lower rsi_entry from 21 to 18\")

CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_with_fallbacks "$prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate hill climbing ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "hill-climbing"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Hill climbing ideas generated successfully"
  return 0
}

# Generate structural mutation ideas using direct CSV modification
generate_structural_mutation_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count structural mutation ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $count structural modification ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use one of these exact parent IDs: $valid_parent_ids

Successful algorithms to modify structurally:
$top_performers

CRITICAL INSTRUCTION: Before generating structural modification ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

Instructions:
1. Use the Read tool to examine the current CSV file
2. Use the Edit or MultiEdit tool to add exactly $count new rows to the CSV file
3. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
4. For each idea, create a row with: id,parent_id,description,,pending
5. Each parent_id MUST be one of: $valid_parent_ids
6. Each description should focus on architectural/structural changes based on the parent's actual code
7. Reference actual components/methods found in the source code

CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_with_fallbacks "$prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate structural mutation ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "structural"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Structural mutation ideas generated successfully"
  return 0
}

# Generate crossover hybrid ideas using direct CSV modification
generate_crossover_direct() {
  local count="$1"
  local top_performers="$2"
  
  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $count crossover hybrid ideas..."
  local data_rows=$(grep -v '^[[:space:]]*$' "$FULL_CSV_PATH" | tail -n +2 | wc -l)
  echo "[DEBUG] Original CSV has $data_rows data rows" >&2
  
  # Extract just the IDs from top performers for clarity
  local valid_parent_ids
  valid_parent_ids=$(echo "$top_performers" | cut -d',' -f1 | paste -sd ',' -)
  
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $count hybrid combination ideas to the CSV file: $temp_csv_basename

IMPORTANT: You MUST use ONLY these exact parent IDs: $valid_parent_ids

Top performers to combine (reference at least 2 in each idea):
$top_performers

CRITICAL INSTRUCTION: Before generating hybrid combination ideas, you MUST read the source code of the parent algorithms.
Algorithm source files are located at: evolution_<PARENT_ID>.py
For example: evolution_gen01-251.py

Instructions:
1. Use the Read tool to examine the current CSV file
2. Use the Edit or MultiEdit tool to add exactly $count new rows to the CSV file
3. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
4. For each idea, create a row with: id,parent_id,description,,pending
5. Each parent_id MUST be one of: $valid_parent_ids (choose the primary parent)
6. Each description should combine actual elements from 2+ algorithms based on their source code
7. Reference specific components/features found in the actual source code

CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_with_fallbacks "$prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate crossover hybrid ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$count" "crossover"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Crossover hybrid ideas generated successfully"
  return 0
}

# Legacy AI generation mode (for backward compatibility)
ideate_ai_legacy() {
  if [[ ! -f "$FULL_BRIEF_PATH" ]]; then
    echo "[ERROR] $BRIEF_FILE not found. Run 'claude-evolve setup' first." >&2
    exit 1
  fi

  # Create temporary CSV copy in evolution directory (so AI can access it)
  local temp_csv="$FULL_EVOLUTION_DIR/temp-csv-$$.csv"
  cp "$FULL_CSV_PATH" "$temp_csv"
  
  echo "[INFO] Generating $TOTAL_IDEAS ideas (legacy mode)..."
  echo "[DEBUG] Original CSV has $(wc -l < "$FULL_CSV_PATH") lines" >&2

  # Get top performers for context
  local top_performers=""
  if [[ -f "$FULL_CSV_PATH" ]]; then
    # Simple top performers extraction (lines with non-empty performance)
    top_performers=$(awk -F, 'NR > 1 && $4 != "" { print $1 ": " $3 " (score: " $4 ")" }' "$FULL_CSV_PATH" | head -5)
  fi

  # Build prompt for direct CSV modification
  # Use relative paths and change to evolution directory so AI can access files
  local temp_csv_basename=$(basename "$temp_csv")
  
  local prompt="I need you to use your file editing capabilities to add exactly $TOTAL_IDEAS algorithmic ideas to the CSV file: $temp_csv_basename

Algorithm files for context:
- Base algorithm: algorithm.py  
- Evolved algorithms: evolution_*.py

IMPORTANT: Before generating ideas, you should:
1. Use the Read tool to examine the base algorithm to understand the codebase structure and possibilities
2. Use the Read tool to examine ALL existing evolution_*.py files to see what modifications have been attempted
3. Consider which approaches might work well

Project Brief:
$(cat "$FULL_BRIEF_PATH")"

  if [[ -n $top_performers ]]; then
    prompt+="

Top Performing Algorithms So Far:
$top_performers"
  fi

  prompt+="

Instructions:
1. Use the Read tool to examine the current CSV file
2. Use the Edit or MultiEdit tool to add exactly $TOTAL_IDEAS new rows to the CSV file
3. Use the next available generation numbers (gen$CURRENT_GENERATION-XXX format)
4. For each idea, create a row with: id,parent_id,description,,pending
5. Mix both parameter tuning and structural changes
6. If building on existing algorithms, use their ID as parent_id, otherwise leave parent_id empty

⚠️ AVOID ONLY: Kelly floor/cap adjustments that assume leverage > 1.0 (these get clamped and have no effect)

✅ EXPLORE ALL CREATIVE POSSIBILITIES INCLUDING:
- Machine Learning: Neural networks, ensemble methods, reinforcement learning (use train() method)
- Advanced Indicators: Custom combinations, multi-timeframe signals, cross-asset indicators
- Market Regime Detection: VIX patterns, correlation analysis, volatility clustering
- Risk Management: Dynamic stops, portfolio heat, correlation-based position sizing
- Alternative Strategies: New sub-strategies, momentum variants, mean reversion innovations
- Multi-Asset Signals: Sector rotation, bond yields, commodity signals
- Time-Based Patterns: Intraday effects, calendar anomalies, volatility timing
- Parameter Optimization: Entry thresholds, indicator periods, strategy weights

CRITICAL: You must use your file editing tools (Edit/MultiEdit) to modify the CSV file. DO NOT return CSV text - use your tools to edit the file directly."

  # Change to evolution directory so AI can access files
  local original_pwd=$(pwd)
  cd "$FULL_EVOLUTION_DIR"
  
  # Get AI to directly edit the CSV file
  local ai_response
  local stderr_file="stderr-$$.txt"
  if ! ai_response=$(call_ai_with_fallbacks "$prompt" "$CURRENT_GENERATION" 2>"$stderr_file"); then
    echo "[ERROR] All AI models failed to generate ideas" >&2
    cat "$stderr_file" >&2
    cd "$original_pwd"
    rm -f "$temp_csv" "$stderr_file"
    return 1
  fi
  rm -f "$stderr_file"
  
  # Restore working directory
  cd "$original_pwd"
  
  echo "[DEBUG] AI response: $ai_response" >&2
  
  # Validate that the CSV file was actually modified
  if ! validate_direct_csv_modification "$temp_csv" "$TOTAL_IDEAS" "mixed"; then
    rm -f "$temp_csv"
    return 1
  fi
  
  echo "[INFO] Legacy ideas generated"
  return 0
}

# Determine generation number for this ideation run
CURRENT_GENERATION=$(get_next_generation)
echo "[INFO] Starting ideation for generation $CURRENT_GENERATION"

# Main execution
if [[ $use_strategies == true ]]; then
  echo "[INFO] Multi-strategy AI generation mode"
  ideate_ai_strategies
  echo "[INFO] Ideation complete! Check $EVOLUTION_CSV for new ideas."
else
  echo "[INFO] Legacy AI generation mode"
  ideate_ai_legacy
  echo "[INFO] Ideation complete! Check $EVOLUTION_CSV for new ideas."
fi