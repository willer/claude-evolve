#!/bin/bash
set -e

# Source configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
source "$SCRIPT_DIR/../lib/config.sh"
source "$SCRIPT_DIR/../lib/csv-lock.sh"

# Load config using the same logic as dispatcher
if [[ -n ${CLAUDE_EVOLVE_CONFIG:-} ]]; then
  load_config "$CLAUDE_EVOLVE_CONFIG"
else
  load_config
fi

# Parse arguments
timeout_seconds=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    --timeout)
      timeout_seconds="$2"
      shift 2
      ;;
    *)
      echo "[ERROR] Unknown argument: $1" >&2
      exit 1
      ;;
  esac
done

# Validate paths
if [[ ! -f "$FULL_CSV_PATH" ]]; then
  echo "[WORKER-$$] CSV file not found: $FULL_CSV_PATH" >&2
  exit 1
fi

# Process a single candidate
process_candidate() {
  local candidate_id="$1"
  local parent_id="$2"
  local description="$3"
  
  echo "[WORKER-$$] Processing candidate ID: $candidate_id"
  echo "[WORKER-$$] Description: $description"
  echo "[WORKER-$$] Based on ID: $parent_id"
  
  # Determine source algorithm
  local source_file
  if [[ -z "$parent_id" ]]; then
    echo "[WORKER-$$] Using base algorithm"
    source_file="$FULL_ALGORITHM_PATH"
  else
    echo "[WORKER-$$] Using parent algorithm: $parent_id"
    source_file="$FULL_OUTPUT_DIR/evolution_${parent_id}.py"
    if [[ ! -f "$source_file" ]]; then
      echo "[WORKER-$$] ERROR: Parent algorithm not found: $source_file" >&2
      return 1
    fi
  fi
  
  # Target file for evolution
  local target_file="$FULL_OUTPUT_DIR/evolution_${candidate_id}.py"
  
  # Check if processing should be skipped
  if [[ -f "$target_file" ]]; then
    echo "[WORKER-$$] ï¿½  Skipping copy - File already exists - skipping all processing"
    echo "[WORKER-$$] ï¿½  Skipping Claude processing - File already exists - skipping all processing"
    
    # Check if already evaluated
    local current_status
    current_status=$("$PYTHON_CMD" -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR/..')
from lib.evolution_csv import EvolutionCSV
with EvolutionCSV('$FULL_CSV_PATH') as csv:
    candidate = csv.get_candidate_info('$candidate_id')
    if candidate:
        print(candidate.get('status', 'unknown'))
    else:
        print('unknown')
")
    
    if [[ "$current_status" == "complete" ]]; then
      echo "[WORKER-$$] Already evaluated - skipping"
      return 0
    fi
    
    # Run evaluation only
    echo "[WORKER-$$] Running evaluation..."
  else
    # Copy source to target
    echo "[WORKER-$$] Copying $source_file to $target_file"
    cp "$source_file" "$target_file"
    
    # Apply evolution using Claude
    echo "[WORKER-$$] Applying evolution with Claude..."
    local evolution_prompt="Modify the algorithm in $target_file based on this description: $description
    
The modification should be substantial and follow the description exactly. Make sure the algorithm still follows all interface requirements and can run properly.

Important: Make meaningful changes that match the description. Don't just add comments or make trivial adjustments."
    
    if ! echo "$evolution_prompt" | claude --dangerously-skip-permissions -p 2>&1; then
      echo "[WORKER-$$] ERROR: Claude evolution failed" >&2
      rm -f "$target_file"  # Clean up on failure
      return 1
    fi
    
    echo "[WORKER-$$] Evolution applied successfully"
  fi
  
  # Run evaluation
  echo "[WORKER-$$] Evaluating algorithm..."
  local eval_output
  local eval_start=$(date +%s)
  
  # Prepare evaluation command
  local eval_cmd=("$PYTHON_CMD" "$FULL_EVALUATOR_PATH" "$candidate_id")
  [[ -n "$timeout_seconds" ]] && eval_cmd=(timeout "$timeout_seconds" "${eval_cmd[@]}")
  
  # Run evaluation and capture output
  if eval_output=$("${eval_cmd[@]}" 2>&1); then
    local eval_end=$(date +%s)
    local eval_duration=$((eval_end - eval_start))
    
    # Extract performance score - support multiple formats
    # Try to parse the output and extract score
    local score_and_json=$("$PYTHON_CMD" -c "
import sys
import json
import re

output = '''$eval_output'''

# Try different formats
score = None
json_data = None

# Format 1: Simple numeric value (just a number on a line)
for line in output.strip().split('\n'):
    line = line.strip()
    if line and not line.startswith('{'):
        try:
            score = float(line)
            break
        except ValueError:
            pass

# Format 2: JSON with 'performance' or 'score' field
if score is None:
    for line in output.strip().split('\n'):
        line = line.strip()
        if line.startswith('{'):
            try:
                data = json.loads(line)
                json_data = data
                if 'performance' in data:
                    score = float(data['performance'])
                elif 'score' in data:
                    score = float(data['score'])
                break
            except (json.JSONDecodeError, ValueError, KeyError):
                pass

# Format 3: SCORE: prefix (backward compatibility)
if score is None:
    match = re.search(r'^SCORE:\s*([+-]?\d*\.?\d+)', output, re.MULTILINE)
    if match:
        try:
            score = float(match.group(1))
        except ValueError:
            pass

# Output results
if score is not None:
    print(f'SCORE={score}')
    if json_data:
        print('JSON_DATA=' + json.dumps(json_data))
else:
    print('SCORE=NONE')
")
    
    # Parse the Python output
    local score=""
    local json_data=""
    while IFS= read -r line; do
      if [[ "$line" =~ ^SCORE=(.*)$ ]]; then
        score="${BASH_REMATCH[1]}"
      elif [[ "$line" =~ ^JSON_DATA=(.*)$ ]]; then
        json_data="${BASH_REMATCH[1]}"
      fi
    done <<< "$score_and_json"
    
    if [[ "$score" != "NONE" ]] && [[ -n "$score" ]]; then
      echo "[WORKER-$$] Evaluation complete: score=$score (${eval_duration}s)"
      
      # Update CSV with result
      if [[ -n "$json_data" ]]; then
        # If we have JSON data, update all fields
        "$PYTHON_CMD" -c "
import sys
import json
sys.path.insert(0, '$SCRIPT_DIR/..')
from lib.evolution_csv import EvolutionCSV

json_data = json.loads('$json_data')
with EvolutionCSV('$FULL_CSV_PATH') as csv:
    csv.update_candidate_status('$candidate_id', 'complete')
    # Update all fields from JSON
    for key, value in json_data.items():
        csv.update_candidate_field('$candidate_id', key, str(value))
"
      else
        # Simple score only
        "$PYTHON_CMD" -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR/..')
from lib.evolution_csv import EvolutionCSV
with EvolutionCSV('$FULL_CSV_PATH') as csv:
    csv.update_candidate_status('$candidate_id', 'complete')
    csv.update_candidate_performance('$candidate_id', '$score')
"
      fi
    else
      echo "[WORKER-$$] ERROR: No score found in evaluation output" >&2
      echo "[WORKER-$$] Output: $eval_output" >&2
      return 1
    fi
  else
    local exit_code=$?
    echo "[WORKER-$$] ERROR: Evaluation failed with exit code $exit_code" >&2
    echo "[WORKER-$$] Output: $eval_output" >&2
    
    # Mark as failed in CSV
    "$PYTHON_CMD" -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR/..')
from lib.evolution_csv import EvolutionCSV
with EvolutionCSV('$FULL_CSV_PATH') as csv:
    csv.update_candidate_status('$candidate_id', 'failed')
"
    
    return $exit_code
  fi
}

# Main worker loop
echo "[WORKER-$$] Worker started"

while true; do
  # Try to claim a pending candidate
  candidate_info=$("$PYTHON_CMD" -c "
import sys
sys.path.insert(0, '$SCRIPT_DIR/..')
from lib.evolution_csv import EvolutionCSV
with EvolutionCSV('$FULL_CSV_PATH') as csv:
    result = csv.get_next_pending_candidate()
    if result:
        candidate_id, _ = result
        # Get full candidate info
        candidate = csv.get_candidate_info(candidate_id)
        if candidate:
            print(f'{candidate[\"id\"]}|{candidate.get(\"parent_id\", \"\")}|{candidate[\"description\"]}')
")
  
  if [[ -z "$candidate_info" ]]; then
    # No pending work
    break
  fi
  
  # Parse candidate info
  IFS='|' read -r candidate_id parent_id description <<< "$candidate_info"
  
  # Process the candidate
  if process_candidate "$candidate_id" "$parent_id" "$description"; then
    echo "[WORKER-$$] Successfully processed $candidate_id"
  else
    echo "[WORKER-$$] Failed to process $candidate_id"
  fi
done

echo "[WORKER-$$] No more pending candidates, worker exiting"