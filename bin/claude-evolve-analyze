#!/bin/bash

set -e

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../lib/config.sh
source "$SCRIPT_DIR/../lib/config.sh"
load_config

# Parse arguments
open_chart=false
csv_file="$FULL_CSV_PATH"
output_file="$FULL_OUTPUT_DIR/performance.png"

while [[ $# -gt 0 ]]; do
  case $1 in
  --help)
    cat <<EOF
claude-evolve analyze - Analyze evolution results

USAGE:
  claude-evolve analyze [--open] [--csv <path>] [--output <path>]

OPTIONS:
  --open            Open the generated chart automatically
  --csv <path>      Path to evolution.csv (default: ./evolution/evolution.csv)
  --output <path>   Output path for chart PNG (default: ./evolution/performance.png)
  --help            Show this help message

DESCRIPTION:
  Analyzes the evolution.csv file and generates a performance chart.
  Displays summary statistics and identifies the top performing algorithm.
EOF
    exit 0
    ;;
  --open)
    open_chart=true
    shift
    ;;
  --csv)
    csv_file="$2"
    shift 2
    ;;
  --output)
    output_file="$2"
    shift 2
    ;;
  *)
    echo "[ERROR] Unknown option: $1" >&2
    exit 1
    ;;
  esac
done

# Check if CSV exists
if [[ ! -f $csv_file ]]; then
  echo "[ERROR] CSV file not found: $csv_file" >&2
  echo "[ERROR] Run 'claude-evolve setup' and 'claude-evolve ideate' first." >&2
  exit 1
fi

echo "=== Evolution Analysis Summary ==="
echo

# Count totals (pure shell)
total=0
completed=0
running=0
failed=0
pending=0
total_performance=0
count_with_performance=0
top_score=""
top_id=""
top_desc=""

while IFS=, read -r id _ desc perf status; do
  [[ $id == "id" ]] && continue # Skip header

  ((total++))

  case "$status" in
  "complete" | "completed") 
    ((completed++))
    # Only count performance for completed runs with non-zero values
    if [[ -n $perf && $perf != "" ]]; then
      # Skip zeros (they're errors)
      if (( $(echo "$perf > 0" | bc -l 2>/dev/null || echo "0") )); then
        total_performance=$(echo "$total_performance + $perf" | bc -l 2>/dev/null || echo "$total_performance")
        ((count_with_performance++))

        # Check if this is the top performer
        if [[ -z $top_score ]] || (($(echo "$perf > $top_score" | bc -l 2>/dev/null || echo "0"))); then
          top_score="$perf"
          top_id="$id"
          top_desc="$desc"
        fi
      fi
    fi
    ;;
  "running") ((running++)) ;;
  "failed" | "timeout" | "interrupted") ((failed++)) ;;
  *) ((pending++)) ;;
  esac
done <"$csv_file"

# Display summary
echo "Total Candidates: $total"
echo "Completed: $completed"
echo "Running: $running"
echo "Failed: $failed"
echo "Pending: $pending"

if [[ $count_with_performance -gt 0 ]]; then
  avg_performance=$(echo "scale=4; $total_performance / $count_with_performance" | bc -l 2>/dev/null || echo "0")
  echo "Average Performance: $avg_performance"
else
  echo "Average Performance: N/A"
fi

echo
echo "=== Top Performer ==="
if [[ -n $top_id ]]; then
  echo "ID: $top_id"
  echo "Performance: $top_score"
  echo "Description: $top_desc"
else
  echo "No completed candidates yet"
fi

# Generation analysis
echo
echo "=== Generation Analysis ==="

# Create temporary file for generation stats
gen_stats_file="/tmp/evolution_gen_stats_$$.tmp"
>"$gen_stats_file"

while IFS=, read -r id _ desc perf status; do
  [[ $id == "id" ]] && continue # Skip header
  
  # Extract generation from ID
  gen="gen01" # default for old numeric IDs
  if [[ $id =~ ^(gen[0-9]+)- ]]; then
    gen="${BASH_REMATCH[1]}"
  elif [[ $id =~ ^[0-9]+$ ]]; then
    gen="gen00" # Mark old numeric IDs as gen00
  fi
  
  # Write generation data to temp file
  echo -n "$gen " >> "$gen_stats_file"
  if [[ $status =~ ^(complete|completed)$ && -n $perf && $perf != "" ]]; then
    # Exclude zeros from statistics (they're errors)
    if (( $(echo "$perf > 0" | bc -l 2>/dev/null || echo "0") )); then
      echo "completed $perf" >> "$gen_stats_file"
    else
      echo "error" >> "$gen_stats_file"
    fi
  else
    echo "incomplete" >> "$gen_stats_file"
  fi
done <"$csv_file"

# Process generation stats
for gen in $(cut -d' ' -f1 "$gen_stats_file" | sort -u || echo ""); do
  [[ -z "$gen" ]] && continue
  total_in_gen=$(grep -c "^$gen " "$gen_stats_file" 2>/dev/null || echo "0")
  completed_in_gen=$(grep -c "^$gen completed" "$gen_stats_file" 2>/dev/null || echo "0")
  # Clean any whitespace from the numbers
  completed_in_gen=$(echo "$completed_in_gen" | tr -d '[:space:]')
  
  echo -n "$gen: $total_in_gen candidates"
  
  if [[ "$completed_in_gen" -gt 0 ]]; then
    # Calculate average performance for this generation  
    sum="0"
    if grep -q "^$gen completed" "$gen_stats_file"; then
      sum=$(grep "^$gen completed" "$gen_stats_file" | awk '{s+=$3} END {printf "%.6f", s}' 2>/dev/null || echo "0")
    fi
    avg=$(echo "scale=4; $sum / $completed_in_gen" | bc -l 2>/dev/null || echo "0")
    echo " ($completed_in_gen completed, avg: $avg)"
  else
    echo " (0 completed)"
  fi
done

rm -f "$gen_stats_file"

# Count valid performance entries for chart (excluding zeros)
valid_performance_count=0
while IFS=, read -r id _ desc perf status; do
  [[ $id == "id" ]] && continue # Skip header
  if [[ $status =~ ^(complete|completed)$ && -n $perf && $perf != "" ]]; then
    if (( $(echo "$perf > 0" | bc -l 2>/dev/null || echo "0") )); then
      ((valid_performance_count++))
    fi
  fi
done <"$csv_file"

# Simple chart generation using gnuplot if available
if command -v gnuplot >/dev/null 2>&1 && [[ $valid_performance_count -gt 0 ]]; then
  echo
  echo "Generating performance chart: $output_file"

  # Create data file for gnuplot with row numbers, excluding zeros
  data_file="/tmp/evolution_data_$$.dat"
  winner_file="/tmp/evolution_winner_$$.dat"
  echo "# Row ID Performance" >"$data_file"

  row_num=0
  max_perf=0
  max_row=0
  max_id=""
  
  while IFS=, read -r id _ desc perf status; do
    [[ $id == "id" ]] && continue # Skip header
    ((row_num++))
    
    # Only include completed algorithms with non-zero performance
    if [[ -n $perf && $perf != "" && $status =~ ^(complete|completed)$ ]]; then
      # Skip zero values (they're errors)
      if (( $(echo "$perf > 0" | bc -l) )); then
        echo "$row_num \"$id\" $perf" >>"$data_file"
        
        # Track the winner
        if (( $(echo "$perf > $max_perf" | bc -l) )); then
          max_perf=$perf
          max_row=$row_num
          max_id=$id
        fi
      fi
    fi
  done <"$csv_file"

  # Create winner data point
  if [[ -n $max_id ]]; then
    echo "$max_row \"$max_id\" $max_perf" >"$winner_file"
  fi

  # Generate plot
  if [[ -s "$data_file" ]]; then
    gnuplot <<EOF
set terminal png size 1000,600
set output "$output_file"
set title "Algorithm Evolution Performance"
set xlabel "Evolution Run"
set ylabel "Performance Score"
set grid
set key off

# Plot the main line in dark blue
plot "$data_file" using 1:3 with linespoints linewidth 2 linecolor rgb "#1f77b4" pointsize 0.8 notitle

# Highlight winner if we have one
$(if [[ -s "$winner_file" ]]; then
  echo "replot \"$winner_file\" using 1:3 with points pointtype 7 pointsize 3 linecolor rgb \"#0000ff\" notitle"
fi)

# Add winner info at bottom
set label "Best: $max_id (Score: $max_perf)" at graph 0.5, 0.02 center font ",12"
replot
EOF
  else
    echo "[WARN] No valid performance data to plot"
    exit 0
  fi

  rm -f "$data_file" "$winner_file"
  echo "Chart saved to: $output_file"

  # Always try to open chart (not just when --open is used)
  if command -v open >/dev/null 2>&1; then
    open "$output_file"
    echo "Opening chart..."
  elif command -v xdg-open >/dev/null 2>&1; then
    xdg-open "$output_file"
    echo "Opening chart..."
  else
    echo "[WARN] Cannot open chart automatically. View: $output_file"
  fi
else
  if [[ $valid_performance_count -eq 0 ]]; then
    echo
    echo "No valid performance data available for chart generation."
    echo "Run 'claude-evolve run' to execute candidates first."
  else
    echo
    echo "[WARN] gnuplot not found. Install gnuplot for chart generation."
    echo "       On macOS: brew install gnuplot"
    echo "       On Ubuntu: sudo apt install gnuplot"
  fi
fi
