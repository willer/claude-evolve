#!/bin/bash

set -e

# Load configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=../lib/config.sh
source "$SCRIPT_DIR/../lib/config.sh"
load_config

# Parse arguments
timeout_seconds=""

while [[ $# -gt 0 ]]; do
  case $1 in
  --timeout)
    if [[ -z ${2:-} ]] || [[ ! $2 =~ ^[0-9]+$ ]] || [[ $2 -eq 0 ]]; then
      echo "[ERROR] --timeout requires a positive integer (seconds)" >&2
      exit 1
    fi
    timeout_seconds="$2"
    shift 2
    ;;
  --help)
    cat <<EOF
claude-evolve run - Execute evolution candidates

USAGE:
  claude-evolve run [OPTIONS]

OPTIONS:
  --timeout <sec>  Kill evaluator after specified seconds (default: no timeout)
  --help           Show this help message

DESCRIPTION:
  Processes the oldest pending candidate from evolution.csv by:
  1. Generating algorithm mutation using Claude
  2. Running evaluator.py on the generated algorithm
  3. Updating CSV with performance score and completion status

  Use --timeout to prevent runaway evaluations from blocking progress.
EOF
    exit 0
    ;;
  *)
    echo "[ERROR] Unknown option: $1" >&2
    exit 1
    ;;
  esac
done

echo "[INFO] Starting evolution run..."
[[ -n $timeout_seconds ]] && echo "[INFO] Using timeout: ${timeout_seconds} seconds"

# Validate workspace using config
if [[ ! -d "$FULL_EVOLUTION_DIR" ]]; then
  echo "[ERROR] Evolution directory not found: $FULL_EVOLUTION_DIR. Run 'claude-evolve setup' first." >&2
  exit 1
fi

# Check required files
if [[ ! -f "$FULL_CSV_PATH" ]]; then
  echo "[ERROR] CSV file not found: $FULL_CSV_PATH" >&2
  exit 1
fi

if [[ ! -f "$FULL_EVALUATOR_PATH" ]]; then
  echo "[ERROR] Evaluator not found: $FULL_EVALUATOR_PATH" >&2
  exit 1
fi

if [[ ! -f "$FULL_ALGORITHM_PATH" ]]; then
  echo "[ERROR] Algorithm not found: $FULL_ALGORITHM_PATH" >&2
  exit 1
fi

# Find oldest pending row (pure shell)
find_empty_row() {
  local row_num=2 # Start after header
  local csv_id csv_based_on csv_desc csv_perf csv_status
  while IFS=, read -r csv_id csv_based_on csv_desc csv_perf csv_status; do
    # Look for rows with pending status or empty status (but not complete/failed/running)
    if [[ $csv_status == "pending" || (-z $csv_perf && -z $csv_status) ]]; then
      echo $row_num
      return 0
    fi
    ((row_num++))
  done < <(tail -n +2 "$FULL_CSV_PATH")
  return 1
}

# Get CSV row (pure shell)
get_csv_row() {
  sed -n "${1}p" "$FULL_CSV_PATH"
}

# Update CSV row (pure shell with temp file)
update_csv_row() {
  local row_num="$1"
  local performance="$2"
  local status="$3"

  # Read CSV and update specific row
  local temp_file="${FULL_CSV_PATH}.tmp"
  local current_row=1
  local csv_id csv_based_on csv_desc csv_perf csv_stat

  while IFS=, read -r csv_id csv_based_on csv_desc csv_perf csv_stat; do
    if [[ $current_row -eq $row_num ]]; then
      # Update this row
      echo "$csv_id,$csv_based_on,$csv_desc,$performance,$status"
    else
      # Keep original row
      echo "$csv_id,$csv_based_on,$csv_desc,$csv_perf,$csv_stat"
    fi
    ((current_row++))
  done <"$FULL_CSV_PATH" >"$temp_file"

  mv "$temp_file" "$FULL_CSV_PATH"
}

# Find next candidate
if ! row_num=$(find_empty_row); then
  echo "[ERROR] No pending candidates found in CSV. Run 'claude-evolve ideate' to add more candidates." >&2
  exit 1
fi

# Get row data
row_data=$(get_csv_row "$row_num")
IFS=, read -r id based_on_id description performance status <<<"$row_data"

# Check if ID is empty
if [[ -z $id ]]; then
  echo "[ERROR] Empty ID found at row $row_num. CSV may be malformed." >&2
  echo "[ERROR] Row data: $row_data" >&2
  exit 1
fi

# Clean up description (remove quotes)
description=${description#\"}
description=${description%\"}

echo "[INFO] Processing candidate ID: $id"
echo "[INFO] Description: $description"
echo "[INFO] Based on ID: $based_on_id"

# Set interrupt handler - just exit without updating CSV status
trap 'echo "[INFO] Evolution interrupted"; exit 130' INT

# Determine parent algorithm
if [[ -z $based_on_id || $based_on_id == "0" || $based_on_id == '""' ]]; then
  # Empty or zero basedonID means use the base algorithm
  parent_file="$FULL_ALGORITHM_PATH"
  echo "[INFO] Using base algorithm (basedonID is empty or 0)"
else
  parent_file="$FULL_OUTPUT_DIR/evolution_id${based_on_id}.py"
  if [[ ! -f $parent_file ]]; then
    echo "[ERROR] Parent algorithm file not found: $parent_file" >&2
    update_csv_row "$row_num" "" "failed"
    exit 1
  fi
fi

echo "[INFO] Using parent algorithm: $parent_file"

# Generate mutation
output_file="$FULL_OUTPUT_DIR/evolution_id${id}.py"
echo "[INFO] Generating algorithm mutation..."

# Copy parent algorithm to output file first
cp "$parent_file" "$output_file"
echo "[INFO] Copied parent algorithm to: $output_file"

# Check for claude CLI
claude_cmd="${CLAUDE_CMD:-claude}"
if ! command -v "$claude_cmd" >/dev/null 2>&1; then
  echo "[ERROR] Claude CLI not found. Please install claude-cli." >&2
  update_csv_row "$row_num" "" "failed"
  exit 1
fi

# Implement claude-fsd style model selection
# Read/create loop counter for megathinking mode
if [[ -f "$FULL_EVOLUTION_DIR/.loop_counter" ]]; then
  LOOP_COUNTER=$(cat "$FULL_EVOLUTION_DIR/.loop_counter")
else
  LOOP_COUNTER=1
fi

# Check if this is the 4th iteration for megathinking mode
if [ $((LOOP_COUNTER % 4)) -eq 0 ]; then
  echo -e "\033[33m**** MEGATHINKING MODE ACTIVATED ****\033[0m"
  CLAUDE_MODEL="opus"
  MEGATHINK_PREFIX="megathink: "
  echo "[INFO] Using Claude Opus for architectural thinking (iteration $LOOP_COUNTER)"
else
  CLAUDE_MODEL="sonnet"
  MEGATHINK_PREFIX=""
  echo "[INFO] Using Claude Sonnet for development (iteration $LOOP_COUNTER)"
fi

# Increment and save counter
echo $((LOOP_COUNTER + 1)) > "$FULL_EVOLUTION_DIR/.loop_counter"

# Create mutation prompt
prompt="${MEGATHINK_PREFIX}You are an AI assistant helping to evolve algorithms through mutations. Please modify the Python algorithm file at $output_file based on the requested modification.

CONTEXT:
$(cat "$FULL_BRIEF_PATH" 2>/dev/null || echo "No brief available")

ALGORITHM FILE TO MODIFY: $output_file

REQUESTED MODIFICATION:
$description

INSTRUCTIONS:
1. Read the existing algorithm file at $output_file
2. Apply the requested modification while preserving the core structure
3. Ensure the modified algorithm maintains the same interface (function signatures)
4. Include proper error handling and documentation
5. Overwrite the file with your improved version
6. Return ONLY the complete Python code without explanation

The output should be a complete, executable Python file that builds upon the existing algorithm."

# Generate mutation (skip for baseline)
if [[ $id == "000" || $id == "0" ]]; then
  echo "[INFO] Baseline algorithm - skipping mutation, using original"
else
  echo "[INFO] Calling Claude $CLAUDE_MODEL to apply mutation..."
  if ! generated_code=$(echo "$prompt" | "$claude_cmd" --model $CLAUDE_MODEL); then
    echo "[ERROR] Claude failed to generate algorithm mutation" >&2
    update_csv_row "$row_num" "" "failed"
    exit 1
  fi
  
  # Save generated algorithm (overwrite the copied file)
  echo "$generated_code" >"$output_file"
  echo "[INFO] Claude successfully mutated algorithm"
fi

echo "[INFO] Algorithm ready at: $output_file"

# Run evaluator
echo "[INFO] Running evaluation..."
echo "[INFO] Executing: $PYTHON_CMD $FULL_EVALUATOR_PATH $output_file"
eval_output=""
eval_exit_code=0

if [[ -n $timeout_seconds ]]; then
  echo "[INFO] Evaluation timeout: ${timeout_seconds}s"
  if eval_output=$(timeout "$timeout_seconds" "$PYTHON_CMD" "$FULL_EVALUATOR_PATH" "$output_file" 2>&1); then
    eval_exit_code=0
  else
    eval_exit_code=$?
    if [[ $eval_exit_code -eq 124 ]]; then
      echo "[ERROR] Evaluation timed out after ${timeout_seconds} seconds" >&2
      update_csv_row "$row_num" "" "timeout"
      exit 1
    fi
  fi
else
  if eval_output=$("$PYTHON_CMD" "$FULL_EVALUATOR_PATH" "$output_file" 2>&1); then
    eval_exit_code=0
  else
    eval_exit_code=$?
  fi
fi

# Show evaluator output
echo "[INFO] Evaluator output:"
echo "----------------------------------------"
echo "$eval_output"
echo "----------------------------------------"

# Process results
if [[ $eval_exit_code -eq 0 ]]; then
  # Extract score from JSON (simple grep approach)
  if score=$(echo "$eval_output" | grep -o '"score"[[:space:]]*:[[:space:]]*[0-9.]*' | cut -d: -f2 | tr -d ' '); then
    if [[ -n $score ]]; then
      update_csv_row "$row_num" "$score" "complete"
      echo "[INFO] ✓ Evaluation completed successfully"
      echo "[INFO] Performance score: $score"
    else
      # Try "performance" field
      if score=$(echo "$eval_output" | grep -o '"performance"[[:space:]]*:[[:space:]]*[0-9.]*' | cut -d: -f2 | tr -d ' '); then
        update_csv_row "$row_num" "$score" "complete"
        echo "[INFO] ✓ Evaluation completed successfully"
        echo "[INFO] Performance score: $score"
      else
        echo "[ERROR] No score found in evaluator output" >&2
        echo "[ERROR] Output: $eval_output" >&2
        update_csv_row "$row_num" "" "failed"
        exit 1
      fi
    fi
  else
    echo "[ERROR] Failed to parse evaluator output" >&2
    echo "[ERROR] Output: $eval_output" >&2
    update_csv_row "$row_num" "" "failed"
    exit 1
  fi
else
  echo "[ERROR] Evaluator failed with exit code $eval_exit_code" >&2
  echo "[ERROR] Output: $eval_output" >&2
  update_csv_row "$row_num" "" "failed"
  exit 1
fi

echo "[INFO] Evolution cycle completed successfully!"
